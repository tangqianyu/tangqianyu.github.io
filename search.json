[{"title":"资源导航","url":"/2020/07/30/资源导航/","content":"\n# 前端\n\n## Angular\n\n### 官方文档\n\n- 中文：[https://angular.cn/docs](https://angular.cn/docs)\n\n- 英文：[https://angular.io/docs](https://angular.io/docs)\n\n### 常用组件库\n\n- Material: [https://material.angular.io/](https://material.angular.io/)\n\n- Ant Design of Angular: [https://ng.ant.design/docs/introduce/zh](https://ng.ant.design/docs/introduce/zh)\n\n- Ant Design Mobile of Angular: [http://ng.mobile.ant.design/#/docs/introduce/zh](http://ng.mobile.ant.design/#/docs/introduce/zh)\n\n- NG-ALAIN: [https://ng-alain.com/docs/getting-started/zh](https://ng-alain.com/docs/getting-started/zh)\n\n\n## react\n\n### 官方文档\n\n- 中文: [https://zh-hans.reactjs.org/docs/getting-started.html](https://zh-hans.reactjs.org/docs/getting-started.html)\n\n- 英文: [https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html)\n\n\n### react-native\n\n- 中文文档: [https://reactnative.cn/docs/getting-started](https://reactnative.cn/docs/getting-started)\n\n- 英文文档: [https://reactnative.dev/docs/getting-started](https://reactnative.dev/docs/getting-started)\n\n\n\n\n# 后端\n\n## Java\n\n### Mybatis\n\n- 中文文档: [https://mybatis.org/mybatis-3/zh/getting-started.html](https://mybatis.org/mybatis-3/zh/getting-started.html)\n\n- 英文文档:[https://mybatis.org/mybatis-3/](https://mybatis.org/mybatis-3/)\n\n\n\n\n\n\n\n"},{"title":"MySQL基础","url":"/2020/07/29/MySQL/","content":"\n## 1、初识MySQL\n\n### 1.1、为什么学习数据库\n\n1、岗位技能需求\n2、现在的世界,得数据者得天下\n3、存储数据的方法\n4、程序,网站中,大量数据如何长久保存?\n5、**数据库是几乎软件体系中最核心的一个存在**。\n\n### 1.2、什么是数据库\n\n数据库 ( **DataBase** , 简称**DB** )\n\n**概念** : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 \"仓库\"\n\n**作用** : 保存,并能安全管理数据(如:增删改查等),减少冗余...\n\n**数据库总览** :\n\n- 关系型数据库 ( SQL )\n  + MySQL , Oracle , SQL Server , SQLite , DB2 , ...\n  + 关系型数据库通过外键关联来建立表与表之间的关系\n- 非关系型数据库 ( NOSQL )\n  + Redis , MongoDB , ...\n  + 非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定\n\n### 1.3、什么是DBMS\n\n数据库管理系统 ( **D**ataBase **M**anagement **S**ystem )\n\n数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据\n\n![640](640.png)\n\n为什么要说这个呢?\n\n因为我们要学习的MySQL应该算是一个数据库管理系统\n\n### 1.4、MySQL简介\n\n![740](740.png)\n\n**概念** : 是现在流行的开源的,免费的 关系型数据库\n\n**历史** : 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。\n\n**特点** :\n  - 免费 , 开源数据库\n  - 小巧 , 功能齐全\n  - 使用便捷\n  - 可运行于Windows或Linux操作系统\n  - 可适用于中小型甚至大型网站应用\n\n官网 : [https://www.mysql.com/](https://www.mysql.com/)\n\n**这里建议大家使用压缩版,安装快,方便.不复杂**\n\n**软件下载**\n\nmysql5.7 64位下载地址:\n\n[https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip](https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip])\n\n电脑是64位的就下载使用64位版本的！\n\n#### 1.4.1、安装步骤\n\n1、下载后得到zip压缩包.\n\n2、解压到自己想要安装到的目录，本人解压到的是D:\\Environment\\mysql-5.7.19\n\n3、添加环境变量：我的电脑->属性->高级->环境变量\n\n`选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹`\n\n4、编辑 my.ini 文件 ,注意替换路径位置\n\n```ini\n[mysqld]\nbasedir=D:\\Program Files\\mysql-5.7\\\ndatadir=D:\\Program Files\\mysql-5.7\\data\\\nport=3306\nskip-grant-tables\n```\n\n5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld –install (安装mysql)\n\n6、再输入  mysqld --initialize-insecure --user=mysql 初始化数据文件\n\n7、然后再次启动mysql 然后用命令 mysql –u root –p 进入mysql管理界面（密码可为空）\n\n8、进入界面后更改root密码\n\n```shell\nupdate mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';\n```\n\n9、刷新权限\n\n```shell\nflush privileges;\n```\n10、修改 my.ini文件删除最后一句skip-grant-tables\n\n11、重启mysql即可正常使用\n\n```shell\nnet stop mysql\nnet start mysql\n```\n\n12、连接上测试出现以下结果就安装好了\n\n![840](840.png)\n\n\n\n## 2、数据库操作\n\n### 2.1、结构化查询语句分类\n\n![940](940.webp)\n\n### 2.2、数据库操作\n\n#### 2.2.1、命令行操作数据库\n\n创建数据库 :  create database [if not exists] 数据库名;\n\n删除数据库 : drop database [if exists] 数据库名;\n\n查看数据库 : show databases;\n\n使用数据库 : use 数据库名;\n\n\n### 2.3、创建数据表\n\n属于DDL的一种，语法 :\n\n```sql\ncreate table [if not exists] `表名`(\n   '字段名1' 列类型 [属性][索引][注释],\n   '字段名2' 列类型 [属性][索引][注释],\n  #...\n   '字段名n' 列类型 [属性][索引][注释]\n)[表类型][表字符集][注释];\n\n```\n**说明** : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键).\n\n### 2.4、数据值和列类型\n\n列类型 : 规定数据库中该列存放的数据类型\n\n#### 2.4.1、数值类型\n\n![1040](1040.webp)\n\n#### 2.4.2、字符串类型\n\n![1140](1140.webp)\n\n#### 2.4.3、日期和时间型数值类型\n\n![1240](1240.webp)\n\n#### 2.4.4、NULL值\n\n- 理解为 \"没有值\" 或 \"未知值\"\n\n- 不要用NULL进行算术运算 , 结果仍为NULL\n\n### 2.5、数据字段属性\n\n<font color=red size=4>UnSigned</font>\n\n- 无符号的\n\n- 声明该数据列不允许负数\n\n<font color=red size=4>ZEROFILL</font>\n\n- 0填充的\n\n- 不足位数的用0来填充 , 如int(3),5则为005\n\n<font color=red size=4>Auto_InCrement</font>\n\n- 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认)\n\n- 通常用于设置主键 , 且为整数类型\n\n- 可定义起始值和步长\n\n  + 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表\n\n  + SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)\n\n<font color=red size=4>NULL 和 NOT NULL</font>\n\n- 默认为NULL , 即没有插入该列的数值\n\n- 如果设置为NOT NULL , 则该列必须有值\n\n<font color=red size=4>DEFAULT</font>\n\n- 默认的\n\n- 用于设置默认值\n\n- 例如,性别字段,默认为\"男\" , 否则为 \"女\" ; 若无指定该列的值 , 则默认值为\"男\"的值  \n\n```sql\n-- 目标 : 创建一个school数据库\n-- 创建学生表(列,字段)\n-- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email\n-- 创建表之前 , 一定要先选择数据库\n\nCREATE TABLE IF NOT EXISTS `student` (\n`id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\n`name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n`pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码',\n`sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别',\n`birthday` datetime DEFAULT NULL COMMENT '生日',\n`address` varchar(100) DEFAULT NULL COMMENT '地址',\n`email` varchar(50) DEFAULT NULL COMMENT '邮箱',\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n-- 查看数据库的定义\nSHOW CREATE DATABASE school;\n-- 查看数据表的定义\nSHOW CREATE TABLE student;\n-- 显示表结构\nDESC student;  -- 设置严格检查模式(不能容错了)SET sql_mode='STRICT_TRANS_TABLES';\n```\n\n### 2.6、数据表的类型\n\n#### 2.6.1、设置数据表的类型\n\n```sql\nCREATE TABLE 表名(\n   -- 省略一些代码\n   -- Mysql注释\n   -- 1. # 单行注释\n   -- 2. /*...*/ 多行注释\n)ENGINE = MyISAM (or InnoDB)\n\n-- 查看mysql所支持的引擎类型 (表类型)\nSHOW ENGINES;\n```\nMySQL的数据表的类型 : **MyISAM** , **InnoDB** , HEAP , BOB , CSV等...\n\n常见的 MyISAM 与 InnoDB 类型：\n\n![1340](1340.webp)\n\n经验 ( 适用场合 )  :\n\n- 适用 MyISAM : 节约空间及相应速度\n\n- 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表\n\n#### 2.6.2、数据表的存储位置\n\n- MySQL数据表以文件方式存放在磁盘中\n\n  + 包括表文件 , 数据文件 , 以及数据库的选项文件\n\n  + 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表\n\n- 注意 :\n\n  + *.frm -- 表结构定义文件\n\n  + *.MYD -- 数据文件 ( data )\n\n  + *.MYI -- 索引文件 ( index )\n\n  + InnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件\n\n  + MyISAM类型数据表对应三个文件 :  \n\n![1440](1440.png)\n\n#### 2.6.3、设置数据表字符集\n\n- 我们可为数据库,数据表,数据列设定不同的字符集，设定方法 :\n\n  + 创建时通过命令来设置 , 如 : CREATE TABLE 表名()CHARSET = utf8;\n\n  + 如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定\n\n### 2.7、修改数据库\n\n#### 2.7.1、修改表 ( ALTER TABLE )\n\n修改表名 :ALTER TABLE 旧表名 RENAME AS 新表名\n\n添加字段 : ALTER TABLE 表名 ADD字段名 列属性[属性]\n\n修改字段 :\n\n- ALTER TABLE 表名 MODIFY 字段名 列类型[属性]\n\n- ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]\n\n删除字段 :  ALTER TABLE 表名 DROP 字段名\n\n#### 2.7.2、删除数据表\n\n语法：DROP TABLE [IF EXISTS] 表名\n\n- IF EXISTS为可选 , 判断是否存在该数据表\n\n- 如删除不存在的数据表会抛出错误\n\n#### 2.7.3、其他\n\n1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！\n\n2. 每个库目录存在一个保存当前数据库的选项文件db.opt。\n\n3. 注释：\n  单行注释 # 注释内容\n  多行注释 /* 注释内容 */\n  单行注释 -- 注释内容       (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)\n   \n4. 模式通配符：\n  _   任意单个字符\n  %   任意多个字符，甚至包括零字符\n  单引号需要进行转义 \\'\n   \n5. CMD命令行内的语句结束符可以为 \";\", \"\\G\", \"\\g\"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。\n\n6. SQL对大小写不敏感 （关键字）\n\n7. 清除已有语句：\\c\n\n\n## 3、DML语言 \n\n### 3.1、外键\n\n#### 3.1.1、外键概念\n\n如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为**主表**，具有此外键的表被称为主表的**从表**。\n\n在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(**foreign key**)。\n\n**外键作用**\n\n保持数据**一致性**，**完整性**，主要目的是控制存储在外键表中的数据,**约束**。使两张表形成关联，外键只能引用外表中的列的值或使用空值。\n\n##### 3.1.2、创建外键\n\n建表时指定外键约束\n\n```sql\n-- 创建外键的方式一 : 创建子表同时创建外键\n\n-- 年级表 (id\\年级名称)\nCREATE TABLE `grade` (\n`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级ID',\n`gradename` VARCHAR(50) NOT NULL COMMENT '年级名称',\nPRIMARY KEY (`gradeid`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\n-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)\nCREATE TABLE `student` (\n`studentno` INT(4) NOT NULL COMMENT '学号',\n`studentname` VARCHAR(20) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n`sex` TINYINT(1) DEFAULT '1' COMMENT '性别',\n`gradeid` INT(10) DEFAULT NULL COMMENT '年级',\n`phoneNum` VARCHAR(50) NOT NULL COMMENT '手机',\n`address` VARCHAR(255) DEFAULT NULL COMMENT '地址',\n`borndate` DATETIME DEFAULT NULL COMMENT '生日',\n`email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱',\n`idCard` VARCHAR(18) DEFAULT NULL COMMENT '身份证号',\nPRIMARY KEY (`studentno`),\nKEY `FK_gradeid` (`gradeid`),\nCONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n```\n\n建表后修改\n\n```sql\n-- 创建外键方式二 : 创建子表完毕后,修改子表添加外键\nALTER TABLE `student`\nADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);\n```\n\n#### 3.1.3、删除外键\n\n操作：删除 grade 表，发现报错\n\n![1540](1540.webp)\n\n**注意** : 删除具有主外键关系的表时 , 要先删子表 , 后删主表\n\n```sql\n-- 删除外键\nALTER TABLE student DROP FOREIGN KEY FK_gradeid;\n-- 发现执行完上面的,索引还在,所以还要删除索引\n-- 注:这个索引是建立外键的时候默认生成的\nALTER TABLE student DROP INDEX FK_gradeid;\n```\n\n\n### 3.2、DML语言\n\n**数据库意义** ：数据存储、数据管理\n\n**管理数据库数据方法**：\n\n- 通过SQLyog等管理工具管理数据库数据\n\n- 通过DML语句管理数据库数据\n\n**DML语言** ：数据操作语言\n\n- 用于操作数据库对象中所包含的数据\n\n- 包括 :\n\n  + INSERT (添加数据语句)\n\n  + UPDATE (更新数据语句)\n\n  + DELETE (删除数据语句)\n\n### 3.3、添加数据\n\n#### 3.3.1、INSERT命令\n\n**语法**：\n\n```sql\nINSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3')\n```\n\n**注意** : \n\n- 字段或值之间用英文逗号隔开 .\n\n- ' 字段1,字段2...' 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 .\n\n- 可同时插入多条数据 , values 后用英文逗号隔开.\n\n```sql\n-- 使用语句如何增加语句?\n-- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3')\nINSERT INTO grade(gradename) VALUES ('大一');\n\n-- 主键自增,那能否省略呢?\nINSERT INTO grade VALUES ('大二');\n\n-- 查询:INSERT INTO grade VALUE ('大二')错误代码：1136\nColumn count doesn`t match value count at row 1\n\n-- 结论:'字段1,字段2...'该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致.\n\n-- 一次插入多条数据\nINSERT INTO grade(gradename) VALUES ('大三'),('大四');\n```\n\n### 3.4、修改数据\n\n#### 3.4.1、update命令\n\n语法：\n\n```sql\nUPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition];\n```\n\n**注意** : \n\n- column_name 为要更改的数据列\n\n- value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果\n\n- condition 为筛选条件 , 如不指定则修改该表的所有列数据\n\n#### 3.4.2、where条件子句\n\n可以简单的理解为 : 有条件地从表中筛选数据\n\n![1640](1640.webp)\n\n测试：\n\n```sql\n-- 修改年级信息\nUPDATE grade SET gradename = '高中' WHERE gradeid = 1;\n```\n\n### 3.5、删除数据\n\n#### 3.5.1、DELETE命令\n\n语法：\n\n```sql\nDELETE FROM 表名 [WHERE condition];\n```\n\n注意：condition为筛选条件 , 如不指定则删除该表的所有列数据\n\n```sql\n-- 删除最后一个数据\nDELETE FROM grade WHERE gradeid = 5\n```\n\n#### 3.5.2、TRUNCATE命令\n\n作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;\n\n语法：\n\n```sql\nTRUNCATE [TABLE] table_name;\n\n-- 清空年级表\nTRUNCATE grade\n```\n**注意：区别于DELETE命令**\n\n- 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快\n\n- 不同 :\n\n  + 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器\n\n  + 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说）\n\n测试：\n\n```sql\n-- 创建一个测试表\nCREATE TABLE `test` (\n`id` INT(4) NOT NULL AUTO_INCREMENT,\n`coll` VARCHAR(20) NOT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\n-- 插入几个测试数据\nINSERT INTO test(coll) VALUES('row1'),('row2'),('row3');\n\n-- 删除表数据(不带where条件的delete)\nDELETE FROM test;\n-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志.\n\n-- 删除表数据(truncate)\nTRUNCATE TABLE test;\n-- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志.\n\n-- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后\n-- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失)\n-- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失)\n```\n\n## 4、DQL语言\n\n**DQL( Data Query Language 数据查询语言 )**\n\n查询数据库数据 , 如**SELECT**语句\n\n简单的单表查询或多表的复杂查询和嵌套查询\n\n是数据库语言中最核心,最重要的语句\n\n使用频率最高的语句\n\n### 4.1、SELECT语法\n\n```sql\nSELECT [ALL | DISTINCT]\n{* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]}\nFROM table_name [as table_alias]\n  [left | right | inner join table_name2]  -- 联合查询\n  [WHERE ...]  -- 指定结果需满足的条件\n  [GROUP BY ...]  -- 指定结果按照哪几个字段来分组\n  [HAVING]  -- 过滤分组的记录必须满足的次要条件\n  [ORDER BY ...]  -- 指定查询记录按一个或多个条件排序\n  [LIMIT {[offset,]row_count | row_countOFFSET offset}];\n   -- 指定查询的记录从哪条至哪条\n```\n\n**注意 : [ ] 括号代表可选的 , { }括号代表必选得**\n\n### 4.2、指定查询字段\n\n```sql\n-- 查询表中所有的数据列结果 , 采用 **\" \\* \"** 符号; 但是效率低，不推荐 .\n\n-- 查询所有学生信息\nSELECT * FROM student;\n\n-- 查询指定列(学号 , 姓名)\nSELECT studentno,studentname FROM student;\n```\n\n#### 4.2.1、AS 子句作为别名\n\n作用：\n\n- 可给数据列取一个新别名\n\n- 可给表取一个新别名\n\n- 可把经计算或总结的结果用另一个新名称来代替\n\n```sql\n-- 这里是为列取别名(当然as关键词可以省略)\nSELECT studentno AS 学号,studentname AS 姓名 FROM student;\n\n-- 使用as也可以为表取别名\nSELECT studentno AS 学号,studentname AS 姓名 FROM student AS s;\n\n-- 使用as,为查询结果取一个新名字\n-- CONCAT()函数拼接字符串\nSELECT CONCAT('姓名:',studentname) AS 新姓名 FROM student;\n```\n\n#### 4.2.2、DISTINCT关键字的使用\n\n作用 : 去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条\n\n```sql\n-- # 查看哪些同学参加了考试(学号) 去除重复项\nSELECT * FROM result; -- 查看考试成绩\nSELECT studentno FROM result; -- 查看哪些同学参加了考试\nSELECT DISTINCT studentno FROM result; -- 了解:DISTINCT 去除重复项 , (默认是ALL)\n```\n\n#### 4.2.3、使用表达式的列\n\n数据库中的表达式 : 一般由文本值 , 列值 , NULL , 函数和操作符等组成\n\n应用场景 :\n\n- SELECT语句返回结果列中使用\n\n- SELECT语句中的ORDER BY , HAVING等子句中使用\n\n- DML语句中的 where 条件语句中使用表达式\n\n```sql\n-- selcet查询中可以使用表达式\nSELECT @@auto_increment_increment; -- 查询自增步长\nSELECT VERSION(); -- 查询版本号\nSELECT 100*3-1 AS 计算结果; -- 表达式\n\n-- 学员考试成绩集体提分一分查看\nSELECT studentno,StudentResult+1 AS '提分后' FROM result;\n```\n- 避免SQL返回结果中包含 ' . ' , ' * ' 和括号等干扰开发语言程序.\n\n\n\n\n### 4.3、where条件语句\n\n作用：用于检索数据表中 符合条件 的记录\n\n搜索条件可由一个或多个逻辑表达式组成 , 结果一般为真或假.\n\n#### 4.3.1、逻辑操作符\n\n![1740](1740.webp)\n\n测试\n\n```sql\n-- 满足条件的查询(where)\nSELECT Studentno,StudentResult FROM result;\n\n-- 查询考试成绩在95-100之间的\nSELECT Studentno,StudentResult\nFROM result\nWHERE StudentResult>=95 AND StudentResult<=100;\n\n-- AND也可以写成 &&\nSELECT Studentno,StudentResult\nFROM result\nWHERE StudentResult>=95 && StudentResult<=100;\n\n-- 模糊查询(对应的词:精确查询)\nSELECT Studentno,StudentResult\nFROM result\nWHERE StudentResult BETWEEN 95 AND 100;\n\n-- 除了1000号同学,要其他同学的成绩\nSELECT studentno,studentresult\nFROM result\nWHERE studentno!=1000;\n\n-- 使用NOT\nSELECT studentno,studentresult\nFROM result\nWHERE NOT studentno=1000;\n```\n\n#### 4.3.2、模糊查询 ：比较操作符\n\n![1840](1840.png)\n\n注意：\n\n- 数值数据类型的记录之间才能进行算术运算 ;\n\n- 相同数据类型的数据之间才能进行比较 ;\n\n测试：\n\n```sql\n-- 模糊查询 between and \\ like \\ in \\ null\n\n-- =============================================\n-- LIKE\n-- =============================================\n-- 查询姓刘的同学的学号及姓名\n-- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符)\nSELECT studentno,studentname FROM student\nWHERE studentname LIKE '刘%';\n\n-- 查询姓刘的同学,后面只有一个字的\nSELECT studentno,studentname FROM student\nWHERE studentname LIKE '刘_';\n\n-- 查询姓刘的同学,后面只有两个字的\nSELECT studentno,studentname FROM student\nWHERE studentname LIKE '刘__';\n\n-- 查询姓名中含有 嘉 字的\nSELECT studentno,studentname FROM student\nWHERE studentname LIKE '%嘉%';\n\n-- 查询姓名中含有特殊字符的需要使用转义符号 '\\'\n-- 自定义转义符关键字: ESCAPE ':'\n\n-- =============================================\n-- IN\n-- =============================================\n-- 查询学号为1000,1001,1002的学生姓名\nSELECT studentno,studentname FROM student\nWHERE studentno IN (1000,1001,1002);\n\n-- 查询地址在北京,南京,河南洛阳的学生\nSELECT studentno,studentname,address FROM student\nWHERE address IN ('北京','南京','河南洛阳');\n\n-- =============================================\n-- NULL 空\n-- =============================================\n-- 查询出生日期没有填写的同学\n-- 不能直接写=NULL , 这是代表错误的 , 用 is null\nSELECT studentname FROM student\nWHERE BornDate IS NULL;\n\n-- 查询出生日期填写的同学\nSELECT studentname FROM student\nWHERE BornDate IS NOT NULL;\n\n-- 查询没有写家庭住址的同学(空字符串不等于null)\nSELECT studentname FROM student\nWHERE Address='' OR Address IS NULL;\n```\n\n\n\n\n### 4.4、连接查询\n\n#### 4.4.1、JOIN 对比\n\n![1940](1940.webp)\n\n七种Join：\n\n![2040](2040.webp)\n\n测试:\n\n```sql\n/*\n连接查询\n   如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询\n内连接 inner join\n   查询两个表中的结果集中的交集\n外连接 outer join\n   左外连接 left join\n       (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充)\n   右外连接 right join\n       (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充)\n       \n等值连接和非等值连接\n\n自连接\n*/\n\n-- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数)\nSELECT * FROM student;\nSELECT * FROM result;\n\n/*思路:\n(1):分析需求,确定查询的列来源于两个类,student result,连接查询\n(2):确定使用哪种连接查询?(内连接)\n*/\nSELECT s.studentno,studentname,subjectno,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\n\n-- 右连接(也可实现)\nSELECT s.studentno,studentname,subjectno,StudentResult\nFROM student s\nRIGHT JOIN result r\nON r.studentno = s.studentno\n\n-- 等值连接\nSELECT s.studentno,studentname,subjectno,StudentResult\nFROM student s , result r\nWHERE r.studentno = s.studentno\n\n-- 左连接 (查询了所有同学,不考试的也会查出来)\nSELECT s.studentno,studentname,subjectno,StudentResult\nFROM student s\nLEFT JOIN result r\nON r.studentno = s.studentno\n\n-- 查一下缺考的同学(左连接应用场景)\nSELECT s.studentno,studentname,subjectno,StudentResult\nFROM student s\nLEFT JOIN result r\nON r.studentno = s.studentno\nWHERE StudentResult IS NULL\n\n-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数)\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON sub.subjectno = r.subjectno\n```\n\n\n#### 4.4.2、自连接\n\n```sql\n/*\n自连接\n   数据表与自身进行连接\n\n需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中\n    查询父栏目名称和其他子栏目名称\n*/\n\n-- 创建一个表\nCREATE TABLE `category` (\n`categoryid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主题id',\n`pid` INT(10) NOT NULL COMMENT '父id',\n`categoryName` VARCHAR(50) NOT NULL COMMENT '主题名字',\nPRIMARY KEY (`categoryid`)\n) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8\n\n-- 插入数据\nINSERT INTO `category` (`categoryid`, `pid`, `categoryName`)\nVALUES('2','1','信息技术'),\n('3','1','软件开发'),\n('4','3','数据库'),\n('5','1','美术设计'),\n('6','3','web开发'),\n('7','5','ps技术'),\n('8','2','办公信息');\n\n-- 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称)\n-- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接)\nSELECT a.categoryName AS '父栏目',b.categoryName AS '子栏目'\nFROM category AS a,category AS b\nWHERE a.`categoryid`=b.`pid`\n\n-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数)\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON sub.subjectno = r.subjectno\n\n-- 查询学员及所属的年级(学号,学生姓名,年级名)\nSELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称\nFROM student s\nINNER JOIN grade g\nON s.`GradeId` = g.`GradeID`\n\n-- 查询科目及所属的年级(科目名称,年级名称)\nSELECT subjectname AS 科目名称,gradename AS 年级名称\nFROM SUBJECT sub\nINNER JOIN grade g\nON sub.gradeid = g.gradeid\n\n-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='数据库结构-1'\n```\n\n### 4.5、排序和分页\n\n测试：\n\n```sql\n/*============== 排序 ================\n语法 : ORDER BY\n   ORDER BY 语句用于根据指定的列对结果集进行排序。\n   ORDER BY 语句默认按照ASC升序对记录进行排序。\n   如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n   \n*/\n\n-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)\n-- 按成绩降序排序\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='数据库结构-1'\nORDER BY StudentResult DESC\n\n/*============== 分页 ================\n语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset\n好处 : (用户体验,网络传输,查询压力)\n\n推导:\n   第一页 : limit 0,5\n   第二页 : limit 5,5\n   第三页 : limit 10,5\n   ......\n   第N页 : limit (pageNo-1)*pageSzie,pageSzie\n   [pageNo:页码,pageSize:单页面显示条数]\n   \n*/\n\n-- 每页显示5条数据\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='数据库结构-1'\nORDER BY StudentResult DESC , studentno\nLIMIT 0,5\n\n-- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数)\nSELECT s.studentno,studentname,subjectname,StudentResult\nFROM student s\nINNER JOIN result r\nON r.studentno = s.studentno\nINNER JOIN `subject` sub\nON r.subjectno = sub.subjectno\nWHERE subjectname='JAVA第一学年'\nORDER BY StudentResult DESC\nLIMIT 0,10\n```\n\n### 4.6、子查询\n\n```sql\n/*============== 子查询 ================\n什么是子查询?\n   在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句\n   嵌套查询可由多个子查询组成,求解的方式是由里及外;\n   子查询返回的结果一般都是集合,故而建议使用IN关键字;\n*/\n\n-- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列\n-- 方法一:使用连接查询\nSELECT studentno,r.subjectno,StudentResult\nFROM result r\nINNER JOIN `subject` sub\nON r.`SubjectNo`=sub.`SubjectNo`\nWHERE subjectname = '数据库结构-1'\nORDER BY studentresult DESC;\n\n-- 方法二:使用子查询(执行顺序:由里及外)\nSELECT studentno,subjectno,StudentResult\nFROM result\nWHERE subjectno=(\n   SELECT subjectno FROM `subject`\n   WHERE subjectname = '数据库结构-1'\n)\nORDER BY studentresult DESC;\n\n-- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名\n-- 方法一:使用连接查询\nSELECT s.studentno,studentname\nFROM student s\nINNER JOIN result r\nON s.`StudentNo` = r.`StudentNo`\nINNER JOIN `subject` sub\nON sub.`SubjectNo` = r.`SubjectNo`\nWHERE subjectname = '高等数学-2' AND StudentResult>=80\n\n-- 方法二:使用连接查询+子查询\n-- 分数不小于80分的学生的学号和姓名\nSELECT r.studentno,studentname FROM student s\nINNER JOIN result r ON s.`StudentNo`=r.`StudentNo`\nWHERE StudentResult>=80\n\n-- 在上面SQL基础上,添加需求:课程为 高等数学-2\nSELECT r.studentno,studentname FROM student s\nINNER JOIN result r ON s.`StudentNo`=r.`StudentNo`\nWHERE StudentResult>=80 AND subjectno=(\n   SELECT subjectno FROM `subject`\n   WHERE subjectname = '高等数学-2'\n)\n\n-- 方法三:使用子查询\n-- 分步写简单sql语句,然后将其嵌套起来\nSELECT studentno,studentname FROM student WHERE studentno IN(\n   SELECT studentno FROM result WHERE StudentResult>=80 AND subjectno=(\n       SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2'\n  )\n)\n\n/*\n练习题目:\n   查 C语言-1 的前5名学生的成绩信息(学号,姓名,分数)\n   使用子查询,查询郭靖同学所在的年级名称\n*/\n```","tags":["基础"],"categories":["MySQL"]},{"title":"Mybatis基础","url":"/2020/07/29/Mybatis/","content":"\n## 1、简介\n\n### 1.1、什么是Mybatis\n\n![1569633932712](Mybatis/1569633932712.png)\n\n- MyBatis 是一款优秀的**持久层框架**\n- 它支持定制化 SQL、存储过程以及高级映射。\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n- MyBatis 本是[apache](https://baike.baidu.com/item/apache/6265)的一个开源项目[iBatis](https://baike.baidu.com/item/iBatis), 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。\n- 2013年11月迁移到Github。\n\n\n\n如何获得Mybatis？\n\n- maven仓库：\n\n  ```xml\n  <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\n  <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.2</version>\n  </dependency>\n  ```\n\n- Github ： https://github.com/mybatis/mybatis-3/releases\n\n- 中文文档：https://mybatis.org/mybatis-3/zh/index.html\n\n\n\n### 1.2、持久化\n\n数据持久化\n\n- 持久化就是将程序的数据在持久状态和瞬时状态转化的过程\n- 内存：**断电即失**\n- 数据库(Jdbc)，io文件持久化。\n- 生活：冷藏. 罐头。\n\n**为什么需要需要持久化？**\n\n- 有一些对象，不能让他丢掉。\n\n- 内存太贵了\n\n\n\n### 1.3、持久层\n\nDao层，Service层，Controller层….\n\n- 完成持久化工作的代码块\n- 层界限十分明显。\n\n\n\n### 1.4 为什么需要Mybatis？\n\n- 帮助程序猿将数据存入到数据库中。\n- 方便\n- 传统的JDBC代码太复杂了。简化。框架。自动化。\n- 不用Mybatis也可以。更容易上手。 **技术没有高低之分**\n- 优点：\n  - 简单易学\n  - 灵活\n  - sql和代码的分离，提高了可维护性。\n  - 提供映射标签，支持对象与数据库的orm字段关系映射\n  - 提供对象关系映射标签，支持对象关系组建维护\n  - 提供xml标签，支持编写动态sql。\n\n\n\n**最重要的一点：使用的人多！**\n\nSpring   SpringMVC    SpringBoot\n\n\n\n## 2、第一个Mybatis程序\n\n思路：搭建环境-->导入Mybatis-->编写代码-->测试！\n\n### 2.1、搭建环境\n\n搭建数据库\n\n```java\nCREATE DATABASE `mybatis`;\n\nUSE `mybatis`;\n\nCREATE TABLE `user`(\n  `id` INT(20) NOT NULL PRIMARY KEY,\n  `name` VARCHAR(30) DEFAULT NULL,\n  `pwd` VARCHAR(30) DEFAULT NULL\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `user`(`id`,`name`,`pwd`) VALUES \n(1,'狂神','123456'),\n(2,'张三','123456'),\n(3,'李四','123890')\n```\n\n新建项目\n\n1. 新建一个普通的maven项目\n\n2. 删除src目录\n\n3. 导入maven依赖\n\n   ```xml\n   \n       <!--导入依赖-->\n       <dependencies>\n           <!--mysql驱动-->\n           <dependency>\n               <groupId>mysql</groupId>\n               <artifactId>mysql-connector-java</artifactId>\n               <version>5.1.47</version>\n           </dependency>\n           <!--mybatis-->\n           <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\n           <dependency>\n               <groupId>org.mybatis</groupId>\n               <artifactId>mybatis</artifactId>\n               <version>3.5.2</version>\n           </dependency>\n           <!--junit-->\n           <dependency>\n               <groupId>junit</groupId>\n               <artifactId>junit</artifactId>\n               <version>4.12</version>\n           </dependency>\n       </dependencies>\n   ```\n\n### 2.2、创建一个模块\n\n- 编写mybatis的核心配置文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n  <!DOCTYPE configuration\n          PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n          \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n  <!--configuration核心配置文件-->\n  <configuration>\n  \n      <environments default=\"development\">\n          <environment id=\"development\">\n              <transactionManager type=\"JDBC\"/>\n              <dataSource type=\"POOLED\">\n                  <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                  <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8\"/>\n                  <property name=\"username\" value=\"root\"/>\n                  <property name=\"password\" value=\"123456\"/>\n              </dataSource>\n          </environment>\n      </environments>\n  \n  </configuration>\n  ```\n\n- 编写mybatis工具类\n\n  ```java\n  //sqlSessionFactory --> sqlSession\n  public class MybatisUtils {\n  \n      private static SqlSessionFactory sqlSessionFactory;\n  \n      static{\n          try {\n              //使用Mybatis第一步：获取sqlSessionFactory对象\n              String resource = \"mybatis-config.xml\";\n              InputStream inputStream = Resources.getResourceAsStream(resource);\n              sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n  \n      }\n  \n      //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。\n      // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。\n      public static SqlSession  getSqlSession(){\n          return sqlSessionFactory.openSession();\n      }\n  \n  }\n  \n  ```\n\n### 2.3、编写代码\n\n- 实体类\n\n  ```java\n  package com.kuang.pojo;\n  \n  //实体类\n  public class User {\n      private int id;\n      private String name;\n      private String pwd;\n  \n      public User() {\n      }\n  \n      public User(int id, String name, String pwd) {\n          this.id = id;\n          this.name = name;\n          this.pwd = pwd;\n      }\n  \n      public int getId() {\n          return id;\n      }\n  \n      public void setId(int id) {\n          this.id = id;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public String getPwd() {\n          return pwd;\n      }\n  \n      public void setPwd(String pwd) {\n          this.pwd = pwd;\n      }\n  \n      @Override\n      public String toString() {\n          return \"User{\" +\n                  \"id=\" + id +\n                  \", name='\" + name + '\\'' +\n                  \", pwd='\" + pwd + '\\'' +\n                  '}';\n      }\n  }\n  \n  ```\n\n- Dao接口\n\n  ```java\n  public interface UserDao {\n      List<User> getUserList();\n  }\n  ```\n\n- 接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件.\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n          <!DOCTYPE mapper\n                  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n                  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n          <!--namespace=绑定一个对应的Dao/Mapper接口-->\n  <mapper namespace=\"com.kuang.dao.UserDao\">\n  \n  <!--select查询语句-->\n     <select id=\"getUserList\" resultType=\"com.kuang.pojo.User\">\n         select * from mybatis.user\n     </select>\n  \n  </mapper>\n  ```\n\n### 2.4、测试\n\n注意点：\n\norg.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry.\n\n**MapperRegistry是什么？**\n\n核心配置文件中注册 mappers\n\n- junit测试\n\n  ```java\n  @Test\n  public void test(){\n      //第一步：获得SqlSession对象\n      SqlSession sqlSession = MybatisUtils.getSqlSession();\n  \n  \n      //方式一：getMapper\n      UserDao userDao = sqlSession.getMapper(UserDao.class);\n      List<User> userList = userDao.getUserList();\n  \n      for (User user : userList) {\n          System.out.println(user);\n      }\n  \n  \n  \n      //关闭SqlSession\n      sqlSession.close();\n  }\n  \n  ```\n\n\n\n你们可以能会遇到的问题：\n\n1. 配置文件没有注册\n2. 绑定接口错误。\n3. 方法名不对\n4. 返回类型不对\n5. Maven导出资源问题\n\n\n\n## 3、CRUD\n\n### 1、namespace\n\nnamespace中的包名要和 Dao/mapper 接口的包名一致！\n\n### 2、select\n\n选择，查询语句;\n\n- id : 就是对应的namespace中的方法名；\n- resultType：Sql语句执行的返回值！\n- parameterType ： 参数类型！\n\n\n\n1. 编写接口\n\n   ```java\n   //根据ID查询用户\n   User getUserById(int id);\n   ```\n   \n2. 编写对应的mapper中的sql语句\n\n   ```java\n   <select id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\">\n           select * from mybatis.user where id = #{id}\n   </select>\n   \n   ```\n\n3. 测试\n\n   ```java\n       @Test\n       public void getUserById() {\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n   \n           User user = mapper.getUserById(1);\n           System.out.println(user);\n   \n           sqlSession.close();\n       }\n   \n   ```\n\n### 3、Insert\n\n```xml\n    <!--对象中的属性，可以直接取出来-->\n    <insert id=\"addUser\" parameterType=\"com.kuang.pojo.User\">\n        insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd});\n    </insert>\n```\n\n### 4、update\n\n```xml\n    <update id=\"updateUser\" parameterType=\"com.kuang.pojo.User\">\n        update mybatis.user set name=#{name},pwd=#{pwd}  where id = #{id} ;\n    </update>\n\n```\n\n### 5、Delete\n\n```xml\n    <delete id=\"deleteUser\" parameterType=\"int\">\n        delete from mybatis.user where id = #{id};\n    </delete>\n```\n\n\n\n注意点：\n\n- 增删改需要提交事务！\n\n\n\n### 6、分析错误\n\n- 标签不要匹配错\n- resource 绑定mapper，需要使用路径！\n- 程序配置文件必须符合规范！\n- NullPointerException，没有注册到资源!\n- 输出的xml文件中存在中文乱码问题！\n- maven资源没有导出问题！\n\n\n\n### 7、万能Map\n\n假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！\n\n```java\n    //万能的Map\n    int addUser2(Map<String,Object> map);\n\n```\n\n```xml\n\n    <!--对象中的属性，可以直接取出来    传递map的key-->\n    <insert id=\"addUser\" parameterType=\"map\">\n        insert into mybatis.user (id, pwd) values (#{userid},#{passWord});\n    </insert>\n```\n\n```xml\n    @Test\n    public void addUser2(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n\n        Map<String, Object> map = new HashMap<String, Object>();\n\n        map.put(\"userid\",5);\n        map.put(\"passWord\",\"2222333\");\n\n        mapper.addUser2(map);\n\n        sqlSession.close();\n    }\n\n```\n\n\n\nMap传递参数，直接在sql中取出key即可！    【parameterType=\"map\"】\n\n对象传递参数，直接在sql中取对象的属性即可！【parameterType=\"Object\"】\n\n只有一个基本类型参数的情况下，可以直接在sql中取到！\n\n多个参数用Map，**或者注解！**\n\n### 8、思考题\n\n模糊查询怎么写？\n\n1. Java代码执行的时候，传递通配符 % %\n\n   ```java\n   List<User> userList = mapper.getUserLike(\"%李%\");\n   ```\n\n2. 在sql拼接中使用通配符！\n\n   ```java\n   select * from mybatis.user where name like \"%\"#{value}\"%\"\n   ```\n\n\n\n## 4、配置解析\n\n### 1、核心配置文件\n\n- mybatis-config.xml\n\n- MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 \n\n  ```xml\n  configuration（配置）\n  properties（属性）\n  settings（设置）\n  typeAliases（类型别名）\n  typeHandlers（类型处理器）\n  objectFactory（对象工厂）\n  plugins（插件）\n  environments（环境配置）\n  environment（环境变量）\n  transactionManager（事务管理器）\n  dataSource（数据源）\n  databaseIdProvider（数据库厂商标识）\n  mappers（映射器）\n  ```\n\n### 2、环境配置（environments）\n\nMyBatis 可以配置成适应多种环境\n\n**不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。**\n\n学会使用配置多套运行环境！\n\nMybatis默认的事务管理器就是 JDBC  ， 连接池 ： POOLED\n\n### 3、属性（properties）\n\n我们可以通过properties属性来实现引用配置文件\n\n这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。【db.properties】\n\n![1569656528134](Mybatis/1569656528134.png)\n\n编写一个配置文件\n\ndb.properties\n\n```properties\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&useUnicode=true&characterEncoding=UTF-8\nusername=root\npassword=123456\n```\n\n在核心配置文件中映入\n\n```xml\n    <!--引入外部配置文件-->\n    <properties resource=\"db.properties\">\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"pwd\" value=\"11111\"/>\n    </properties>\n\n```\n\n- 可以直接引入外部文件\n- 可以在其中增加一些属性配置\n- 如果两个文件有同一个字段，优先使用外部配置文件的！\n\n\n\n### 4、类型别名（typeAliases）\n\n- 类型别名是为 Java 类型设置一个短的名字。‘\n- 存在的意义仅在于用来减少类完全限定名的冗余。\n\n```xml\n    <!--可以给实体类起别名-->\n    <typeAliases>\n        <typeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/>\n    </typeAliases>\n```\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：\n\n扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！\n\n```xml\n<!--可以给实体类起别名-->\n<typeAliases>\n    <package name=\"com.kuang.pojo\"/>\n</typeAliases>\n```\n\n\n\n在实体类比较少的时候，使用第一种方式。\n\n如果实体类十分多，建议使用第二种。\n\n第一种可以DIY别名，第二种则·不行·，如果非要改，需要在实体上增加注解\n\n```java\n@Alias(\"user\")\npublic class User {}\n```\n\n### 5、设置\n\n这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 \n\n![1569657659080](Mybatis/1569657659080.png)\n\n![1569657672791](Mybatis/1569657672791.png)\n\n### 6、其他配置\n\n- [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)\n- [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)\n- plugins插件\n  - mybatis-generator-core\n  - mybatis-plus\n  - 通用mapper\n\n### 7、映射器（mappers）\n\nMapperRegistry：注册绑定我们的Mapper文件；\n\n方式一： 【推荐使用】\n\n```xml\n<!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！-->\n<mappers>\n    <mapper resource=\"com/kuang/dao/UserMapper.xml\"/>\n</mappers>\n```\n\n方式二：使用class文件绑定注册\n\n```xml\n<!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！-->\n<mappers>\n    <mapper class=\"com.kuang.dao.UserMapper\"/>\n</mappers>\n```\n\n注意点：\n\n- 接口和他的Mapper配置文件必须同名！\n- 接口和他的Mapper配置文件必须在同一个包下！\n\n\n\n方式三：使用扫描包进行注入绑定\n\n```xml\n<!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！-->\n<mappers>\n    <package name=\"com.kuang.dao\"/>\n</mappers>\n```\n\n注意点：\n\n- 接口和他的Mapper配置文件必须同名！\n- 接口和他的Mapper配置文件必须在同一个包下！\n\n\n\n练习时间：\n\n- 将数据库配置文件外部引入\n- 实体类别名\n- 保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！\n\n\n\n### 8、生命周期和作用域\n\n![1569660357745](Mybatis/1569660357745.png)\n\n生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的**并发问题**。\n\n**SqlSessionFactoryBuilder：**\n\n- 一旦创建了 SqlSessionFactory，就不再需要它了\n- 局部变量\n\n**SqlSessionFactory：**\n\n- 说白了就是可以想象为 ：数据库连接池\n- SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，**没有任何理由丢弃它或重新创建另一个实例。** \n- 因此 SqlSessionFactory 的最佳作用域是应用作用域。 \n- 最简单的就是使用**单例模式**或者静态单例模式。\n\n**SqlSession**\n\n- 连接到连接池的一个请求！\n- SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n- 用完之后需要赶紧关闭，否则资源被占用！\n\n![1569660737088](Mybatis/1569660737088.png)\n\n这里面的每一个Mapper，就代表一个具体的业务！\n\n\n\n## 5、解决属性名和字段名不一致的问题\n\n### 1、 问题\n\n数据库中的字段\n\n![1569660831076](Mybatis/1569660831076.png)\n\n新建一个项目，拷贝之前的，测试实体类字段不一致的情况\n\n```java\npublic class User {\n    \n    private int id;\n    private String name;\n    private String password;\n}\n```\n\n测试出现问题\n\n![1569661145806](Mybatis/1569661145806.png)\n\n\n\n```xml\n//    select * from mybatis.user where id = #{id}\n//类型处理器\n//    select id,name,pwd from mybatis.user where id = #{id}\n```\n\n\n\n解决方法：\n\n- 起别名\n\n  ```xml\n  <select id=\"getUserById\" resultType=\"com.kuang.pojo.User\">\n      select id,name,pwd as password from mybatis.user where id = #{id}\n  </select>\n  ```\n\n\n\n### 2、resultMap\n\n结果集映射\n\n```\nid   name   pwd\nid   name   password\n```\n\n```xml\n<!--结果集映射-->\n<resultMap id=\"UserMap\" type=\"User\">\n    <!--column数据库中的字段，property实体类中的属性-->\n    <result column=\"id\" property=\"id\"/>\n    <result column=\"name\" property=\"name\"/>\n    <result column=\"pwd\" property=\"password\"/>\n</resultMap>\n\n<select id=\"getUserById\" resultMap=\"UserMap\">\n    select * from mybatis.user where id = #{id}\n</select>\n```\n\n\n\n- `resultMap` 元素是 MyBatis 中最重要最强大的元素\n- ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。\n- `ResultMap` 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。\n-  如果世界总是这么简单就好了。\n\n\n\n## 6、日志\n\n### 6.1、日志工厂\n\n如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！\n\n曾经：sout 、debug\n\n现在：日志工厂！\n\n![1569892155104](Mybatis/1569892155104.png)\n\n- SLF4J \n\n- LOG4J  【掌握】\n- LOG4J2\n-  JDK_LOGGING\n- COMMONS_LOGGING\n- STDOUT_LOGGING   【掌握】\n- NO_LOGGING\n\n\n\n在Mybatis中具体使用那个一日志实现，在设置中设定！\n\n**STDOUT_LOGGING标准日志输出**\n\n在mybatis核心配置文件中，配置我们的日志！\n\n```xml\n<settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n![1569892595060](Mybatis/1569892595060.png)\n\n\n\n### 6.2、Log4j\n\n什么是Log4j？\n\n- Log4j是[Apache](https://baike.baidu.com/item/Apache/8512995)的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626)、文件、[GUI](https://baike.baidu.com/item/GUI)组件\n- 我们也可以控制每一条日志的输出格式；\n- 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n- 通过一个[配置文件](https://baike.baidu.com/item/配置文件/286550)来灵活地进行配置，而不需要修改应用的代码。\n\n\n\n1. 先导入log4j的包\n\n   ```xml\n   <!-- https://mvnrepository.com/artifact/log4j/log4j -->\n   <dependency>\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n       <version>1.2.17</version>\n   </dependency>\n   ```\n\n2. log4j.properties\n\n   ```properties\n   #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\n   log4j.rootLogger=DEBUG,console,file\n   \n   #控制台输出的相关设置\n   log4j.appender.console = org.apache.log4j.ConsoleAppender\n   log4j.appender.console.Target = System.out\n   log4j.appender.console.Threshold=DEBUG\n   log4j.appender.console.layout = org.apache.log4j.PatternLayout\n   log4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n   \n   #文件输出的相关设置\n   log4j.appender.file = org.apache.log4j.RollingFileAppender\n   log4j.appender.file.File=./log/kuang.log\n   log4j.appender.file.MaxFileSize=10mb\n   log4j.appender.file.Threshold=DEBUG\n   log4j.appender.file.layout=org.apache.log4j.PatternLayout\n   log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n   \n   #日志输出级别\n   log4j.logger.org.mybatis=DEBUG\n   log4j.logger.java.sql=DEBUG\n   log4j.logger.java.sql.Statement=DEBUG\n   log4j.logger.java.sql.ResultSet=DEBUG\n   log4j.logger.java.sql.PreparedStatement=DEBUG\n   ```\n\n3. 配置log4j为日志的实现\n\n   ```xml\n   <settings>\n       <setting name=\"logImpl\" value=\"\"/>\n   </settings>\n   ```\n\n4. Log4j的使用！，直接测试运行刚才的查询\n\n   ![1569893505842](Mybatis/1569893505842.png)\n\n\n\n**简单使用**\n\n1. 在要使用Log4j 的类中，导入包  import org.apache.log4j.Logger;\n\n2. 日志对象，参数为当前类的class\n\n   ```java\n   static Logger logger = Logger.getLogger(UserDaoTest.class);\n   ```\n\n3. 日志级别\n\n   ```java\n   logger.info(\"info:进入了testLog4j\");\n   logger.debug(\"debug:进入了testLog4j\");\n   logger.error(\"error:进入了testLog4j\");\n   ```\n\n\n\n## 7、分页\n\n**思考：为什么要分页？**\n\n- 减少数据的处理量\n\n\n\n### 7.1、使用Limit分页\n\n```sql\n语法：SELECT * from user limit startIndex,pageSize;\nSELECT * from user limit 3;  #[0,n]\n```\n\n\n\n使用Mybatis实现分页，核心SQL\n\n1. 接口\n\n   ```java\n   //分页\n   List<User> getUserByLimit(Map<String,Integer> map);\n   ```\n\n2. Mapper.xml\n\n   ```xml\n   <!--//分页-->\n   <select id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\">\n       select * from  mybatis.user limit #{startIndex},#{pageSize}\n   </select>\n   ```\n\n3. 测试\n\n   ```java\n   @Test\n   public void getUserByLimit(){\n   SqlSession sqlSession = MybatisUtils.getSqlSession();\n   UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n   \n   HashMap<String, Integer> map = new HashMap<String, Integer>();\n       map.put(\"startIndex\",1);\n       map.put(\"pageSize\",2);\n   \n       List<User> userList =  mapper.getUserByLimit(map);\n       for (User user : userList) {\n       System.out.println(user);\n       }\n   \n       sqlSession.close();\n       }\n   \n   ```\n\n   \n\n### 7.2、RowBounds分页\n\n不再使用SQL实现分页\n\n1. 接口\n\n   ```java\n   //分页2\n   List<User> getUserByRowBounds();\n   ```\n\n2. mapper.xml\n\n   ```xml\n   <!--分页2-->\n   <select id=\"getUserByRowBounds\" resultMap=\"UserMap\">\n       select * from  mybatis.user\n   </select>\n   ```\n\n3. 测试\n\n   ```java\n   @Test\n   public void getUserByRowBounds(){\n   SqlSession sqlSession = MybatisUtils.getSqlSession();\n   \n   //RowBounds实现\n   RowBounds rowBounds = new RowBounds(1, 2);\n   \n   //通过Java代码层面实现分页\n   List<User> userList = sqlSession.selectList(\"com.kuang.dao.UserMapper.getUserByRowBounds\",null,rowBounds);\n   \n       for (User user : userList) {\n       System.out.println(user);\n       }\n   \n       sqlSession.close();\n       }\n   ```\n\n   \n\n### 7.3、分页插件\n\n![1569896603103](Mybatis/1569896603103.png)\n\n了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！\n\n\n\n## 8、使用注解开发\n\n### 8.1、面向接口编程\n\n\\- 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程\n\\- **根本原因 :  ==解耦== , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好**\n\\- 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；\n\\- 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。\n\n\n\n**关于接口的理解**\n\n\\- 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。\n\\- 接口的本身反映了系统设计人员对系统的抽象理解。\n\\- 接口应有两类：\n  \\- 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；\n  \\- 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；\n\\- 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n\n\n\n**三个面向区别**\n\n\\- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .\n\\- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .\n\\- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构\n\n### 8.2、使用注解开发\n\n1. 注解在接口上实现\n\n   ```java\n   @Select(\"select * from user\")\n   List<User> getUsers();\n   ```\n\n2. 需要再核心配置文件中绑定接口！\n\n   ```xml\n   <!--绑定接口-->\n   <mappers>\n       <mapper class=\"com.kuang.dao.UserMapper\"/>\n   </mappers>\n   ```\n\n3. 测试\n\n\n\n本质：反射机制实现\n\n底层：动态代理！\n\n ![1569898830704](Mybatis/1569898830704.png)\n\n\n\n**Mybatis详细的执行流程！**\n\n![1569898830704](Mybatis/Temp.png)\n\n\n\n\n\n### 8.3、CRUD\n\n我们可以在工具类创建的时候实现自动提交事务！\n\n```java\npublic static SqlSession  getSqlSession(){\n    return sqlSessionFactory.openSession(true);\n}\n```\n\n\n\n编写接口，增加注解\n\n```java\npublic interface UserMapper {\n\n    @Select(\"select * from user\")\n    List<User> getUsers();\n\n    // 方法存在多个参数，所有的参数前面必须加上 @Param(\"id\")注解\n    @Select(\"select * from user where id = #{id}\")\n    User getUserByID(@Param(\"id\") int id);\n\n\n    @Insert(\"insert into user(id,name,pwd) values (#{id},#{name},#{password})\")\n    int addUser(User user);\n\n    \n    @Update(\"update user set name=#{name},pwd=#{password} where id = #{id}\")\n    int updateUser(User user);\n\n    \n    @Delete(\"delete from user where id = #{uid}\")\n    int deleteUser(@Param(\"uid\") int id);\n}\n```\n\n\n\n测试类\n\n【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】\n\n\n\n**关于@Param() 注解**\n\n- 基本类型的参数或者String类型，需要加上\n- 引用类型不需要加\n- 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！\n- 我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！\n\n\n\n**#{}     ${} 区别**\n\n\n\n## 9、Lombok\n\n```java\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.\nNever write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n```\n\n- java library\n- plugs\n- build tools\n- with one annotation your class\n\n\n\n使用步骤：\n\n1. 在IDEA中安装Lombok插件！\n\n2. 在项目中导入lombok的jar包\n\n   ```xml\n   <dependency>\n       <groupId>org.projectlombok</groupId>\n       <artifactId>lombok</artifactId>\n       <version>1.18.10</version>\n   </dependency>\n   ```\n\n3. 在实体类上加注解即可！\n\n   ```java\n   @Data\n   @AllArgsConstructor\n   @NoArgsConstructor\n   ```\n\n\n\n```java\n@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger\n@Data\n@Builder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@SneakyThrows\n```\n\n说明：\n\n```\n@Data：无参构造，get、set、tostring、hashcode，equals\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode\n@ToString\n@Getter\n```\n\n\n\n## 10、多对一处理\n\n多对一：\n\n![1569909163944](Mybatis/1569909163944.png)\n\n- 多个学生，对应一个老师\n- 对于学生这边而言，  **关联** ..  多个学生，关联一个老师  【多对一】\n- 对于老师而言， **集合** ， 一个老师，有很多学生 【一对多】\n\n![1569909422471](Mybatis/1569909422471.png)\n\nSQL：\n\n```sql\nCREATE TABLE `teacher` (\n  `id` INT(10) NOT NULL,\n  `name` VARCHAR(30) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师'); \n\nCREATE TABLE `student` (\n  `id` INT(10) NOT NULL,\n  `name` VARCHAR(30) DEFAULT NULL,\n  `tid` INT(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `fktid` (`tid`),\n  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\n\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1');\n\n```\n\n\n\n### 测试环境搭建\n\n1. 导入lombok\n2. 新建实体类 Teacher，Student\n3. 建立Mapper接口\n4. 建立Mapper.XML文件\n5. 在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】\n6. 测试查询是否能够成功！\n\n\n\n### 按照查询嵌套处理\n\n```xml\n<!--\n    思路:\n        1. 查询所有的学生信息\n        2. 根据查询出来的学生的tid，寻找对应的老师！  子查询\n    -->\n\n<select id=\"getStudent\" resultMap=\"StudentTeacher\">\n    select * from student\n</select>\n\n<resultMap id=\"StudentTeacher\" type=\"Student\">\n    <result property=\"id\" column=\"id\"/>\n    <result property=\"name\" column=\"name\"/>\n    <!--复杂的属性，我们需要单独处理 对象： association 集合： collection -->\n    <association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/>\n</resultMap>\n\n<select id=\"getTeacher\" resultType=\"Teacher\">\n    select * from teacher where id = #{id}\n</select>\n\n```\n\n\n\n### 按照结果嵌套处理\n\n```xml\n<!--按照结果嵌套处理-->\n<select id=\"getStudent2\" resultMap=\"StudentTeacher2\">\n    select s.id sid,s.name sname,t.name tname\n    from student s,teacher t\n    where s.tid = t.id;\n</select>\n\n<resultMap id=\"StudentTeacher2\" type=\"Student\">\n    <result property=\"id\" column=\"sid\"/>\n    <result property=\"name\" column=\"sname\"/>\n    <association property=\"teacher\" javaType=\"Teacher\">\n        <result property=\"name\" column=\"tname\"/>\n    </association>\n</resultMap>\n```\n\n\n\n回顾Mysql 多对一查询方式：\n\n- 子查询\n- 联表查询\n\n\n\n## 11、一对多处理\n\n比如：一个老师拥有多个学生！\n\n对于老师而言，就是一对多的关系!\n\n\n\n### 环境搭建\n\n\n\n1. 环境搭建，和刚才一样\n\n**实体类**\n\n```java\n@Data\npublic class Student {\n\n    private int id;\n    private String name;\n    private int tid;\n\n}\n\n```\n\n```java\n@Data\npublic class Teacher {\n    private int id;\n    private String name;\n\n    //一个老师拥有多个学生\n    private List<Student> students;\n}\n```\n\n\n\n\n\n### 按照结果嵌套处理\n\n```xml\n\n    <!--按结果嵌套查询-->\n    <select id=\"getTeacher\" resultMap=\"TeacherStudent\">\n        select s.id sid, s.name sname, t.name tname,t.id tid\n        from student s,teacher t\n        where s.tid = t.id and t.id = #{tid}\n    </select>\n\n    <resultMap id=\"TeacherStudent\" type=\"Teacher\">\n        <result property=\"id\" column=\"tid\"/>\n        <result property=\"name\" column=\"tname\"/>\n        <!--复杂的属性，我们需要单独处理 对象： association 集合： collection\n        javaType=\"\" 指定属性的类型！\n        集合中的泛型信息，我们使用ofType获取\n        -->\n        <collection property=\"students\" ofType=\"Student\">\n            <result property=\"id\" column=\"sid\"/>\n            <result property=\"name\" column=\"sname\"/>\n            <result property=\"tid\" column=\"tid\"/>\n        </collection>\n    </resultMap>\n```\n\n\n\n### 按照查询嵌套处理\n\n```xml\n<select id=\"getTeacher2\" resultMap=\"TeacherStudent2\">\n    select * from mybatis.teacher where id = #{tid}\n</select>\n\n<resultMap id=\"TeacherStudent2\" type=\"Teacher\">\n    <collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentByTeacherId\" column=\"id\"/>\n</resultMap>\n\n<select id=\"getStudentByTeacherId\" resultType=\"Student\">\n    select * from mybatis.student where tid = #{tid}\n</select>\n```\n\n\n\n### 小结\n\n1. 关联 - association   【多对一】\n2. 集合 - collection   【一对多】\n3. javaType    &   ofType\n   1. JavaType  用来指定实体类中属性的类型\n   2. ofType  用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！\n\n\n\n注意点：\n\n- 保证SQL的可读性，尽量保证通俗易懂\n- 注意一对多和多对一中，属性名和字段的问题！\n- 如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j\n\n\n\n**慢SQL       1s        1000s**      \n\n面试高频\n\n- Mysql引擎\n- InnoDB底层原理\n- 索引\n- 索引优化！\n\n\n\n\n\n## 12、动态 SQL\n\n==**什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句**==\n\n利用动态 SQL 这一特性可以彻底摆脱这种痛苦。\n\n```xml\n动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n```\n\n\n\n### 搭建环境\n\n```sql\nCREATE TABLE `blog` (\n  `id` varchar(50) NOT NULL COMMENT '博客id',\n  `title` varchar(100) NOT NULL COMMENT '博客标题',\n  `author` varchar(30) NOT NULL COMMENT '博客作者',\n  `create_time` datetime NOT NULL COMMENT '创建时间',\n  `views` int(30) NOT NULL COMMENT '浏览量'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n```\n\n\n\n创建一个基础工程\n\n1. 导包\n\n2. 编写配置文件\n\n3. 编写实体类\n\n   ```java\n   \n   @Data\n   public class Blog {\n       private int id;\n       private String title;\n       private String author;\n       private Date createTime;\n       private int views;\n       \n       \n   }\n   ```\n\n4. 编写实体类对应Mapper接口 和 Mapper.XML文件\n\n\n\n### IF\n\n```xml\n<select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n    select * from mybatis.blog where 1=1\n    <if test=\"title != null\">\n        and title = #{title}\n    </if>\n    <if test=\"author != null\">\n        and author = #{author}\n    </if>\n</select>\n```\n\n### choose (when, otherwise)\n\n```xml\n\n    <select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\">\n        select * from mybatis.blog\n        <where>\n            <choose>\n                <when test=\"title != null\">\n                    title = #{title}\n                </when>\n                <when test=\"author != null\">\n                    and author = #{author}\n                </when>\n                <otherwise>\n                    and views = #{views}\n                </otherwise>\n            </choose>\n        </where>\n    </select>\n```\n\n\n\n### trim (where,set)\n\n```xml\nselect * from mybatis.blog\n<where>\n    <if test=\"title != null\">\n        title = #{title}\n    </if>\n    <if test=\"author != null\">\n        and author = #{author}\n    </if>\n</where>\n```\n\n```xml\n<update id=\"updateBlog\" parameterType=\"map\">\n    update mybatis.blog\n    <set>\n        <if test=\"title != null\">\n            title = #{title},\n        </if>\n        <if test=\"author != null\">\n            author = #{author}\n        </if>\n    </set>\n    where id = #{id}\n</update>\n\n```\n\n==**所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码**==\n\nif\n\nwhere ， set  ， choose ，when\n\n\n\n\n\n### SQL片段\n\n有的时候，我们可能会将一些功能的部分抽取出来，方便复用！\n\n1. 使用SQL标签抽取公共的部分\n\n   ```xml\n   <sql id=\"if-title-author\">\n       <if test=\"title != null\">\n           title = #{title}\n       </if>\n       <if test=\"author != null\">\n           and author = #{author}\n       </if>\n   </sql>\n   ```\n\n2. 在需要使用的地方使用Include标签引用即可\n\n   ```xml\n   <select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n       select * from mybatis.blog\n       <where>\n           <include refid=\"if-title-author\"></include>\n       </where>\n   </select>\n   ```\n\n   \n\n注意事项：\n\n- 最好基于单表来定义SQL片段！\n- 不要存在where标签\n\n\n\n### Foreach\n\n```sql\nselect * from user where 1=1 and \n\n  <foreach item=\"id\" collection=\"ids\"\n      open=\"(\" separator=\"or\" close=\")\">\n        #{id}\n  </foreach>\n\n(id=1 or id=2 or id=3)\n\n```\n\n![1569979229205](Mybatis/1569979229205.png)\n\n![1569979339190](Mybatis/1569979339190.png)\n\n```xml\n<!--\n        select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3)\n\n        我们现在传递一个万能的map ， 这map中可以存在一个集合！\n-->\n<select id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\">\n    select * from mybatis.blog\n\n    <where>\n        <foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\">\n            id = #{id}\n        </foreach>\n    </where>\n\n</select>\n\n```\n\n\n\n==动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了==\n\n建议：\n\n- 现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！\n\n\n\n## 13、缓存 （了解）\n\n### 13.1、简介\n\n```\n查询  ：  连接数据库 ，耗资源！\n\t一次查询的结果，给他暂存在一个可以直接取到的地方！--> 内存 ： 缓存\n\t\n我们再次查询相同数据的时候，直接走缓存，就不用走数据库了\n```\n\n\n\n1. 什么是缓存 [ Cache ]？\n   - 存在内存中的临时数据。\n   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n2. 为什么使用缓存？\n   \n   - 减少和数据库的交互次数，减少系统开销，提高系统效率。\n3. 什么样的数据能使用缓存？\n   \n   - 经常查询并且不经常改变的数据。【可以使用缓存】\n   \n     \n\n### 13.2、Mybatis缓存\n\n- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**\n  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）\n  \n  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\n  \n  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存\n  \n    \n\n### 13.3、一级缓存\n\n- 一级缓存也叫本地缓存：  SqlSession\n  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。\n  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；\n\n\n\n测试步骤：\n\n1. 开启日志！\n2. 测试在一个Sesion中查询两次相同记录\n3. 查看日志输出\n\n![1569983650437](Mybatis/1569983650437.png)\n\n\n\n缓存失效的情况：\n\n1. 查询不同的东西\n\n2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！\n\n   ![1569983952321](Mybatis/1569983952321.png)\n\n3. 查询不同的Mapper.xml\n\n4. 手动清理缓存！\n\n   ![1569984008824](Mybatis/1569984008824.png)\n\n\n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！\n\n一级缓存就是一个Map。\n\n\n\n\n### 13.4、二级缓存\n\n- 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n- 基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n- 工作机制\n  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；\n  - 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；\n  - 新的会话查询信息，就可以从二级缓存中获取内容；\n  - 不同的mapper查出的数据会放在自己对应的缓存（map）中；\n\n\n\n步骤：\n\n1. 开启全局缓存\n\n   ```xml\n   <!--显示的开启全局缓存-->\n   <setting name=\"cacheEnabled\" value=\"true\"/>\n   ```\n\n2. 在要使用二级缓存的Mapper中开启\n\n   ```xml\n   <!--在当前Mapper.xml中使用二级缓存-->\n   <cache/>\n   ```\n\n   也可以自定义参数\n\n   ```xml\n   <!--在当前Mapper.xml中使用二级缓存-->\n   <cache  eviction=\"FIFO\"\n          flushInterval=\"60000\"\n          size=\"512\"\n          readOnly=\"true\"/>\n   ```\n\n3. 测试\n\n   1. 问题:我们需要将实体类序列化！否则就会报错！\n\n      ```\n      Caused by: java.io.NotSerializableException: com.kuang.pojo.User\n      ```\n\n\n\n小结：\n\n- 只要开启了二级缓存，在同一个Mapper下就有效\n- 所有的数据都会先放在一级缓存中；\n- 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！\n\n\n\n\n\n### 13.5、缓存原理\n\n![1569985541106](Mybatis/1569985541106.png)\n\n\n\n### 13.6、自定义缓存-ehcache\n\n```xml\nEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存\n```\n\n要在程序中使用ehcache，先要导包！\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache -->\n<dependency>\n    <groupId>org.mybatis.caches</groupId>\n    <artifactId>mybatis-ehcache</artifactId>\n    <version>1.1.0</version>\n</dependency>\n```\n\n在mapper中指定使用我们的ehcache缓存实现！\n\n```xml\n<!--在当前Mapper.xml中使用二级缓存-->\n<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n```\n\nehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"false\">\n    <!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     -->\n    <diskStore path=\"./tmpdir/Tmp_EhCache\"/>\n    \n    <defaultCache\n            eternal=\"false\"\n            maxElementsInMemory=\"10000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"259200\"\n            memoryStoreEvictionPolicy=\"LRU\"/>\n \n    <cache\n            name=\"cloud_user\"\n            eternal=\"false\"\n            maxElementsInMemory=\"5000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"1800\"\n            memoryStoreEvictionPolicy=\"LRU\"/>\n    <!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     -->\n    <!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统当机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   -->\n\n</ehcache>\n\n```\n\n\n\nRedis数据库来做缓存！  K-V\n\n\n\n\n## 练习：29道练习题实战！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Mybatis","基础"],"categories":["Java"]},{"title":"JavaWeb基础","url":"/2020/07/29/JavaWeb/","content":"\n# JavaWeb\n\nJava    Web\n\n## 1、基本概念\n\n### 1.1、前言\n\nweb开发：\n\n- web，网页的意思  ， www.baidu.com\n- 静态web\n  - html，css\n  - 提供给所有人看的数据始终不会发生变化！\n- 动态web\n  - 淘宝，几乎是所有的网站；\n  - 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！\n  - 技术栈：Servlet/JSP，ASP，PHP\n\n在Java中，动态web资源开发的技术统称为JavaWeb；\n\n### 1.2、web应用程序\n\nweb应用程序：可以提供浏览器访问的程序；\n\n- a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；\n- 你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。\n- URL \n- 这个统一的web资源会被放在同一个文件夹下，web应用程序-->Tomcat：服务器\n- 一个web应用由多部分组成 （静态web，动态web）\n  - html，css，js\n  - jsp，servlet\n  - Java程序\n  - jar包\n  - 配置文件 （Properties）\n\nweb应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；\n\n### 1.3、静态web\n\n- *.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；\n\n![1567822802516](JavaWeb/1567822802516.png)\n\n- 静态web存在的缺点\n  - Web页面无法动态更新，所有用户看到都是同一个页面\n    - 轮播图，点击特效：伪动态\n    - JavaScript [实际开发中，它用的最多]\n    - VBScript\n  - 它无法和数据库交互（数据无法持久化，用户无法交互）\n\n\n\n### 1.4、动态web\n\n页面会动态展示： “Web的页面展示的效果因人而异”；\n\n![1567823191289](JavaWeb/1567823191289.png)\n\n缺点：\n\n- 加入服务器的动态web资源出现了错误，我们需要重新编写我们的**后台程序**,重新发布；\n  - 停机维护\n\n优点：\n\n- Web页面可以动态更新，所有用户看到都不是同一个页面\n- 它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）\n\n![1567823350584](JavaWeb/1567823350584.png)\n\n新手村：--魔鬼训练（分析原理，看源码）--> PK场\n\n\n\n## 2、web服务器\n\n### 2.1、技术讲解\n\n**ASP:**\n\n- 微软：国内最早流行的就是ASP；\n\n- 在HTML中嵌入了VB的脚本，  ASP + COM；\n\n- 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱\n\n- 维护成本高！\n\n- C# \n\n- IIS\n\n  ```html\n  <h1>\n      <h1><h1>\n          <h1>\n              <h1>\n                  <h1>\n          <h1>\n              <%\n              System.out.println(\"hello\")\n              %>\n              <h1>\n                  <h1>\n     <h1><h1>\n  <h1>\n  ```\n\n  \n\n**php：**\n\n- PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）\n- 无法承载大访问量的情况（局限性）\n\n\n\n**JSP/Servlet : ** \n\nB/S：浏览和服务器\n\nC/S:  客户端和服务器\n\n- sun公司主推的B/S架构\n- 基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)\n- 可以承载三高问题带来的影响；\n- 语法像ASP ， ASP-->JSP , 加强市场强度；\n\n\n\n.....\n\n\n\n### 2.2、web服务器\n\n服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；\n\n\n\n**IIS**\n\n微软的； ASP...,Windows中自带的\n\n**Tomcat**\n\n![1567824446428](JavaWeb/1567824446428.png)\n\n面向百度编程；\n\nTomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且**免费**，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。\n\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用[服务器](https://baike.baidu.com/item/服务器)，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择\n\nTomcat 实际上运行JSP 页面和Servlet。Tomcat最新版本为**9.0。**\n\n....\n\n**工作3-5年之后，可以尝试手写Tomcat服务器；**\n\n下载tomcat：\n\n1. 安装 or  解压\n2. 了解配置文件及目录结构\n3. 这个东西的作用\n\n\n\n## 3、Tomcat\n\n### 3.1、 安装tomcat\n\ntomcat官网：http://tomcat.apache.org/\n\n![1567825600842](JavaWeb/1567825600842.png)\n\n![1567825627138](JavaWeb/1567825627138.png)\n\n\n\n### 3.2、Tomcat启动和配置\n\n文件夹作用：\n\n![1567825763180](JavaWeb/1567825763180.png)\n\n**启动。关闭Tomcat**\n\n![1567825840657](JavaWeb/1567825840657.png)\n\n访问测试：http://localhost:8080/\n\n可能遇到的问题：\n\n1. Java环境变量没有配置\n2. 闪退问题：需要配置兼容性\n3. 乱码问题：配置文件中设置\n\n### 3.3、配置\n\n![1567825967256](JavaWeb/1567825967256.png)\n\n可以配置启动的端口号\n\n- tomcat的默认端口号为：8080\n- mysql：3306\n- http：80\n- https：443\n\n```xml\n<Connector port=\"8081\" protocol=\"HTTP/1.1\"\n           connectionTimeout=\"20000\"\n           redirectPort=\"8443\" />\n```\n可以配置主机的名称\n\n- 默认的主机名为：localhost->127.0.0.1\n- 默认网站应用存放的位置为：webapps\n\n```xml\n  <Host name=\"www.qinjiang.com\"  appBase=\"webapps\"\n        unpackWARs=\"true\" autoDeploy=\"true\">\n```\n#### 高难度面试题：\n\n请你谈谈网站是如何进行访问的！\n\n1. 输入一个域名；回车\n\n2. 检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射；\n\n   1. 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问\n\n      ```java\n      127.0.0.1       www.qinjiang.com\n      ```\n\n   2. 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；\n\n   ![1567827057913](JavaWeb/1567827057913.png)\n\n4. 可以配置一下环境变量（可选性）\n\n### 3.4、发布一个web网站\n\n不会就先模仿\n\n- 将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了\n\n网站应该有的结构\n\n```java\n--webapps ：Tomcat服务器的web目录\n\t-ROOT\n\t-kuangstudy ：网站的目录名\n\t\t- WEB-INF\n\t\t\t-classes : java程序\n\t\t\t-lib：web应用所依赖的jar包\n\t\t\t-web.xml ：网站配置文件\n\t\t- index.html 默认的首页\n\t\t- static \n            -css\n            \t-style.css\n            -js\n            -img\n         -.....\n```\n\n\n\nHTTP协议 ： 面试\n\nMaven：构建工具\n\n- Maven安装包\n\nServlet 入门\n\n- HelloWorld！\n- Servlet配置\n- 原理\n\n\n\n## 4、Http\n\n### 4.1、什么是HTTP\n\nHTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。\n\n- 文本：html，字符串，~ ….\n- 超文本：图片，音乐，视频，定位，地图…….\n- 80\n\nHttps：安全的\n\n- 443\n\n### 4.2、两个时代\n\n- http1.0\n\n  - HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n\n- http2.0\n\n  - HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘\n\n  \n\n### 4.3、Http请求\n\n- 客户端---发请求（Request）---服务器\n\n百度：\n\n```java\nRequest URL:https://www.baidu.com/   请求地址\nRequest Method:GET    get方法/post方法\nStatus Code:200 OK    状态码：200\nRemote（远程） Address:14.215.177.39:443\n```\n\n```java\nAccept:text/html  \nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN,zh;q=0.9    语言\nCache-Control:max-age=0\nConnection:keep-alive\n```\n\n#### 1、请求行\n\n- 请求行中的请求方式：GET\n- 请求方式：**Get，Post**，HEAD,DELETE,PUT,TRACT…\n  - get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效\n  - post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。\n\n#### 2、消息头\n\n```java\nAccept：告诉浏览器，它所支持的数据类型\nAccept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1\nAccept-Language：告诉浏览器，它的语言环境\nCache-Control：缓存控制\nConnection：告诉浏览器，请求完成是断开还是保持连接\nHOST：主机..../.\n```\n\n### 4.4、Http响应\n\n- 服务器---响应-----客户端\n\n百度：\n\n```java\nCache-Control:private    缓存控制\nConnection:Keep-Alive    连接\nContent-Encoding:gzip    编码\nContent-Type:text/html   类型\n```\n\n#### 1.响应体\n\n```java\nAccept：告诉浏览器，它所支持的数据类型\nAccept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1\nAccept-Language：告诉浏览器，它的语言环境\nCache-Control：缓存控制\nConnection：告诉浏览器，请求完成是断开还是保持连接\nHOST：主机..../.\nRefresh：告诉客户端，多久刷新一次；\nLocation：让网页重新定位；\n```\n\n#### 2、响应状态码 \n\n200：请求响应成功  200\n\n3xx：请求重定向 \n\n- 重定向：你重新到我给你新位置去；\n\n4xx：找不到资源   404\n\n- 资源不存在；\n\n5xx：服务器代码错误   500       502:网关错误\n\n\n\n**常见面试题：**\n\n当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？\n\n\n\n\n\n## 5、Maven\n\n**我为什么要学习这个技术？**\n\n1. 在Javaweb开发中，需要使用大量的jar包，我们手动去导入；\n\n2. 如何能够让一个东西自动帮我导入和配置这个jar包。\n\n   由此，Maven诞生了！\n\n\n\n### 5.1 Maven项目架构管理工具\n\n我们目前用来就是方便导入jar包的！\n\nMaven的核心思想：**约定大于配置**\n\n- 有约束，不要去违反。\n\nMaven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；\n\n### 5.2 下载安装Maven\n\n官网;https://maven.apache.org/\n\n![1567842350606](JavaWeb/1567842350606.png)\n\n下载完成后，解压即可；\n\n小狂神友情建议：电脑上的所有环境都放在一个文件夹下，方便管理；\n\n\n\n### 5.3 配置环境变量\n\n在我们的系统环境变量中\n\n配置如下配置：\n\n- M2_HOME     maven目录下的bin目录\n- MAVEN_HOME      maven的目录\n- 在系统的path中配置  %MAVEN_HOME%\\bin\n\n![1567842882993](JavaWeb/1567842882993.png)\n\n测试Maven是否安装成功，保证必须配置完毕！\n\n### 5.4 阿里云镜像\n\n![1567844609399](JavaWeb/1567844609399.png)\n\n- 镜像：mirrors\n  - 作用：加速我们的下载\n- 国内建议使用阿里云的镜像\n\n```xml\n<mirror>\n    <id>nexus-aliyun</id>  \n    <mirrorOf>*,!jeecg,!jeecg-snapshots</mirrorOf>  \n    <name>Nexus aliyun</name>  \n    <url>http://maven.aliyun.com/nexus/content/groups/public</url> \n</mirror>\n```\n\n### 5.5 本地仓库\n\n在本地的仓库，远程仓库；\n\n**建立一个本地仓库：**localRepository\n\n```xml\n<localRepository>D:\\Environment\\apache-maven-3.6.2\\maven-repo</localRepository>\n```\n\n### 5.6、在IDEA中使用Maven\n\n1. 启动IDEA\n\n2. 创建一个MavenWeb项目\n\n   ![1567844785602](JavaWeb/1567844785602.png)\n\n   ![1567844841172](JavaWeb/1567844841172.png)\n\n   ![1567844917185](JavaWeb/1567844917185.png)\n\n   ![1567844956177](JavaWeb/1567844956177.png)\n\n   ![1567845029864](JavaWeb/1567845029864.png)\n\n3. 等待项目初始化完毕\n\n   ![1567845105970](JavaWeb/1567845105970.png)\n\n   ![1567845137978](JavaWeb/1567845137978.png)\n\n4. 观察maven仓库中多了什么东西？\n\n5. IDEA中的Maven设置\n\n   注意：IDEA项目创建成功后，看一眼Maven的配置\n\n   ![1567845341956](JavaWeb/1567845341956.png)\n\n   ![1567845413672](JavaWeb/1567845413672.png)\n\n6. 到这里，Maven在IDEA中的配置和使用就OK了!\n\n### 5.7、创建一个普通的Maven项目\n\n![1567845557744](JavaWeb/1567845557744.png)\n\n![1567845717377](JavaWeb/1567845717377.png)\n\n这个只有在Web应用下才会有！\n\n![1567845782034](JavaWeb/1567845782034.png)\n\n### 5.8 标记文件夹功能\n\n![1567845910728](JavaWeb/1567845910728.png)\n\n![1567845957139](JavaWeb/1567845957139.png)\n\n![1567846034906](JavaWeb/1567846034906.png)\n\n![1567846073511](JavaWeb/1567846073511.png)\n\n### 5.9 在 IDEA中配置Tomcat\n\n![1567846140348](JavaWeb/1567846140348.png)\n\n![1567846179573](JavaWeb/1567846179573.png)\n\n![1567846234175](JavaWeb/1567846234175.png)\n\n![1567846369751](JavaWeb/1567846369751.png)\n\n解决警告问题\n\n必须要的配置：**为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；**\n\n![1567846421963](JavaWeb/1567846421963.png)\n\n![1567846546465](JavaWeb/1567846546465.png)\n\n![1567846559111](JavaWeb/1567846559111.png)\n\n![1567846640372](JavaWeb/1567846640372.png)\n\n### 5.10 pom文件\n\npom.xml 是Maven的核心配置文件\n\n![1567846784849](JavaWeb/1567846784849.png)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--Maven版本和头文件-->\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <!--这里就是我们刚才配置的GAV-->\n  <groupId>com.kuang</groupId>\n  <artifactId>javaweb-01-maven</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <!--Package：项目的打包方式\n  jar：java应用\n  war：JavaWeb应用\n  -->\n  <packaging>war</packaging>\n\n\n  <!--配置-->\n  <properties>\n    <!--项目的默认构建编码-->\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <!--编码版本-->\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n  </properties>\n\n  <!--项目依赖-->\n  <dependencies>\n    <!--具体依赖的jar包配置文件-->\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n  </dependencies>\n\n  <!--项目构建用的东西-->\n  <build>\n    <finalName>javaweb-01-maven</finalName>\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n```\n\n![1567847410771](JavaWeb/1567847410771.png)\n\n\n\nmaven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：\n\n```xml\n<!--在build中配置resources，来防止我们资源导出失败的问题-->\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n```\n\n\n\n### 5.12 IDEA操作\n\n![1567847630808](JavaWeb/1567847630808.png)\n\n\n\n![1567847662429](JavaWeb/1567847662429.png)\n\n\n\n### 5.13 解决遇到的问题\n\n1. Maven 3.6.2\n\n   解决方法：降级为3.6.1\n\n   ![1567904721301](JavaWeb/1567904721301.png)\n\n2. Tomcat闪退\n\n   \n\n3. IDEA中每次都要重复配置Maven\n   在IDEA中的全局默认配置中去配置\n\n   ![1567905247201](JavaWeb/1567905247201.png)\n\n   ![1567905291002](JavaWeb/1567905291002.png)\n\n4. Maven项目中Tomcat无法配置\n\n5. maven默认web项目中的web.xml版本问题\n\n   ![1567905537026](JavaWeb/1567905537026.png)\n\n6. 替换为webapp4.0版本和tomcat一致\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n                         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n            version=\"4.0\"\n            metadata-complete=\"true\">\n   \n   \n   \n   </web-app>\n   ```\n\n   \n\n7. Maven仓库的使用\n\n   地址：https://mvnrepository.com/\n\n   ![1567905870750](JavaWeb/1567905870750.png)\n\n   ![1567905982979](JavaWeb/1567905982979.png)\n\n   ![1567906017448](JavaWeb/1567906017448.png)\n\n   ![1567906039469](JavaWeb/1567906039469.png)\n\n\n\n## 6、Servlet\n\n### 6.1、Servlet简介\n\n- Servlet就是sun公司开发动态web的一门技术\n- Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：\n  - 编写一个类，实现Servlet接口\n  - 把开发好的Java类部署到web服务器中。\n\n**把实现了Servlet接口的Java程序叫做，Servlet**\n\n### 6.2、HelloServlet\n\nSerlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet\n\n\n\n1. 构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程；\n\n2. 关于Maven父子工程的理解：\n\n   父项目中会有\n\n   ```xml\n       <modules>\n           <module>servlet-01</module>\n       </modules>\n   ```\n\n   子项目会有\n\n   ```xml\n       <parent>\n           <artifactId>javaweb-02-servlet</artifactId>\n           <groupId>com.kuang</groupId>\n           <version>1.0-SNAPSHOT</version>\n       </parent>\n   ```\n\n   父项目中的java子项目可以直接使用\n\n   ```java\n   son extends father\n   ```\n\n3. Maven环境优化\n\n   1. 修改web.xml为最新的\n   2. 将maven的结构搭建完整\n\n4. 编写一个Servlet程序\n\n   ![1567911804700](JavaWeb/1567911804700.png)\n\n   1. 编写一个普通类\n\n   2. 实现Servlet接口，这里我们直接继承HttpServlet\n\n      ```java\n      public class HelloServlet extends HttpServlet {\n          \n          //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；\n          @Override\n          protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n              //ServletOutputStream outputStream = resp.getOutputStream();\n              PrintWriter writer = resp.getWriter(); //响应流\n              writer.print(\"Hello,Serlvet\");\n          }\n      \n          @Override\n          protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n              doGet(req, resp);\n          }\n      }\n      \n      ```\n\n5. 编写Servlet的映射\n\n   为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；\n\n   ```xml\n   \n       <!--注册Servlet-->\n       <servlet>\n           <servlet-name>hello</servlet-name>\n           <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n       </servlet>\n       <!--Servlet的请求路径-->\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n   \n   ```\n\n   \n\n6. 配置Tomcat\n\n   注意：配置项目发布的路径就可以了\n\n7. 启动测试，OK！\n\n### 6.3、Servlet原理\n\nServlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：\n\n![1567913793252](JavaWeb/1567913793252.png)\n\n### 6.4、Mapping问题\n\n1. 一个Servlet可以指定一个映射路径\n\n   ```xml\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n   ```\n\n2. 一个Servlet可以指定多个映射路径\n\n   ```xml\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello2</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello3</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello4</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello5</url-pattern>\n       </servlet-mapping>\n   \n   ```\n\n3. 一个Servlet可以指定通用映射路径\n\n   ```xml\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello/*</url-pattern>\n       </servlet-mapping>\n   ```\n\n4. 默认请求路径\n\n   ```xml\n       <!--默认请求路径-->\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/*</url-pattern>\n       </servlet-mapping>\n   ```\n\n5. 指定一些后缀或者前缀等等….\n\n   ```xml\n   \n   <!--可以自定义后缀实现请求映射\n       注意点，*前面不能加项目映射的路径\n       hello/sajdlkajda.qinjiang\n       -->\n   <servlet-mapping>\n       <servlet-name>hello</servlet-name>\n       <url-pattern>*.qinjiang</url-pattern>\n   </servlet-mapping>\n   ```\n\n6. 优先级问题\n   指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；\n\n   ```xml\n   <!--404-->\n   <servlet>\n       <servlet-name>error</servlet-name>\n       <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>\n   </servlet>\n   <servlet-mapping>\n       <servlet-name>error</servlet-name>\n       <url-pattern>/*</url-pattern>\n   </servlet-mapping>\n   \n   ```\n\n   \n\n### 6.5、ServletContext\n\nweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；\n\n#### 1、共享数据\n\n我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；\n\n```java\npublic class HelloServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        \n        //this.getInitParameter()   初始化参数\n        //this.getServletConfig()   Servlet配置\n        //this.getServletContext()  Servlet上下文\n        ServletContext context = this.getServletContext();\n\n        String username = \"秦疆\"; //数据\n        context.setAttribute(\"username\",username); //将一个数据保存在了ServletContext中，名字为：username 。值 username\n\n    }\n\n}\n\n```\n\n```java\npublic class GetServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ServletContext context = this.getServletContext();\n        String username = (String) context.getAttribute(\"username\");\n\n        resp.setContentType(\"text/html\");\n        resp.setCharacterEncoding(\"utf-8\");\n        resp.getWriter().print(\"名字\"+username);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n\n```XML\n    <servlet>\n        <servlet-name>hello</servlet-name>\n        <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>hello</servlet-name>\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n\n\n    <servlet>\n        <servlet-name>getc</servlet-name>\n        <servlet-class>com.kuang.servlet.GetServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>getc</servlet-name>\n        <url-pattern>/getc</url-pattern>\n    </servlet-mapping>\n```\n\n测试访问结果；\n\n\n\n#### 2、获取初始化参数\n\n```xml\n    <!--配置一些web应用初始化参数-->\n    <context-param>\n        <param-name>url</param-name>\n        <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>\n    </context-param>\n```\n\n```java\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    ServletContext context = this.getServletContext();\n    String url = context.getInitParameter(\"url\");\n    resp.getWriter().print(url);\n}\n```\n\n#### 3、请求转发\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    ServletContext context = this.getServletContext();\n    System.out.println(\"进入了ServletDemo04\");\n    //RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/gp\"); //转发的请求路径\n    //requestDispatcher.forward(req,resp); //调用forward实现请求转发；\n    context.getRequestDispatcher(\"/gp\").forward(req,resp);\n}\n```\n\n![1567924457532](JavaWeb/1567924457532.png)\n\n#### 4、读取资源文件\n\nProperties\n\n- 在java目录下新建properties\n- 在resources目录下新建properties\n\n发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:\n\n思路：需要一个文件流；\n\n```properties\nusername=root12312\npassword=zxczxczxc\n```\n\n```java\npublic class ServletDemo05 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/com/kuang/servlet/aa.properties\");\n\n        Properties prop = new Properties();\n        prop.load(is);\n        String user = prop.getProperty(\"username\");\n        String pwd = prop.getProperty(\"password\");\n\n        resp.getWriter().print(user+\":\"+pwd);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n\n访问测试即可ok；\n\n### 6.6、HttpServletResponse\n\nweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；\n\n- 如果要获取客户端请求过来的参数：找HttpServletRequest\n- 如果要给客户端响应一些信息：找HttpServletResponse\n\n#### 1、简单分类\n\n负责向浏览器发送数据的方法\n\n```java\nServletOutputStream getOutputStream() throws IOException;\nPrintWriter getWriter() throws IOException;\n```\n\n负责向浏览器发送响应头的方法\n\n```java\n    void setCharacterEncoding(String var1);\n\n    void setContentLength(int var1);\n\n    void setContentLengthLong(long var1);\n\n    void setContentType(String var1);\n\n    void setDateHeader(String var1, long var2);\n\n    void addDateHeader(String var1, long var2);\n\n    void setHeader(String var1, String var2);\n\n    void addHeader(String var1, String var2);\n\n    void setIntHeader(String var1, int var2);\n\n    void addIntHeader(String var1, int var2);\n```\n\n响应的状态码\n\n```java\n    int SC_CONTINUE = 100;\n    int SC_SWITCHING_PROTOCOLS = 101;\n    int SC_OK = 200;\n    int SC_CREATED = 201;\n    int SC_ACCEPTED = 202;\n    int SC_NON_AUTHORITATIVE_INFORMATION = 203;\n    int SC_NO_CONTENT = 204;\n    int SC_RESET_CONTENT = 205;\n    int SC_PARTIAL_CONTENT = 206;\n    int SC_MULTIPLE_CHOICES = 300;\n    int SC_MOVED_PERMANENTLY = 301;\n    int SC_MOVED_TEMPORARILY = 302;\n    int SC_FOUND = 302;\n    int SC_SEE_OTHER = 303;\n    int SC_NOT_MODIFIED = 304;\n    int SC_USE_PROXY = 305;\n    int SC_TEMPORARY_REDIRECT = 307;\n    int SC_BAD_REQUEST = 400;\n    int SC_UNAUTHORIZED = 401;\n    int SC_PAYMENT_REQUIRED = 402;\n    int SC_FORBIDDEN = 403;\n    int SC_NOT_FOUND = 404;\n    int SC_METHOD_NOT_ALLOWED = 405;\n    int SC_NOT_ACCEPTABLE = 406;\n    int SC_PROXY_AUTHENTICATION_REQUIRED = 407;\n    int SC_REQUEST_TIMEOUT = 408;\n    int SC_CONFLICT = 409;\n    int SC_GONE = 410;\n    int SC_LENGTH_REQUIRED = 411;\n    int SC_PRECONDITION_FAILED = 412;\n    int SC_REQUEST_ENTITY_TOO_LARGE = 413;\n    int SC_REQUEST_URI_TOO_LONG = 414;\n    int SC_UNSUPPORTED_MEDIA_TYPE = 415;\n    int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    int SC_EXPECTATION_FAILED = 417;\n    int SC_INTERNAL_SERVER_ERROR = 500;\n    int SC_NOT_IMPLEMENTED = 501;\n    int SC_BAD_GATEWAY = 502;\n    int SC_SERVICE_UNAVAILABLE = 503;\n    int SC_GATEWAY_TIMEOUT = 504;\n    int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\n```\n\n#### 2、下载文件\n\n1. 向浏览器输出消息 （一直在讲，就不说了）\n2. 下载文件\n   1. 要获取下载文件的路径\n   2. 下载的文件名是啥？\n   3. 设置想办法让浏览器能够支持下载我们需要的东西\n   4. 获取下载文件的输入流\n   5. 创建缓冲区\n   6. 获取OutputStream对象\n   7. 将FileOutputStream流写入到buffer缓冲区\n   8. 使用OutputStream将缓冲区中的数据输出到客户端！\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 1. 要获取下载文件的路径\n    String realPath = \"F:\\\\班级管理\\\\西开【19525】\\\\2、代码\\\\JavaWeb\\\\javaweb-02-servlet\\\\response\\\\target\\\\classes\\\\秦疆.png\";\n    System.out.println(\"下载文件的路径：\"+realPath);\n    // 2. 下载的文件名是啥？\n    String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1);\n    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码\n    resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+URLEncoder.encode(fileName,\"UTF-8\"));\n    // 4. 获取下载文件的输入流\n    FileInputStream in = new FileInputStream(realPath);\n    // 5. 创建缓冲区\n    int len = 0;\n    byte[] buffer = new byte[1024];\n    // 6. 获取OutputStream对象\n    ServletOutputStream out = resp.getOutputStream();\n    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！\n    while ((len=in.read(buffer))>0){\n        out.write(buffer,0,len);\n    }\n\n    in.close();\n    out.close();\n}\n```\n\n#### 3、验证码功能\n\n验证怎么来的？\n\n- 前端实现\n- 后端实现，需要用到 Java 的图片类，生产一个图片\n\n```java\npackage com.kuang.servlet;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\npublic class ImageServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        //如何让浏览器3秒自动刷新一次;\n        resp.setHeader(\"refresh\",\"3\");\n        \n        //在内存中创建一个图片\n        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\n        //得到图片\n        Graphics2D g = (Graphics2D) image.getGraphics(); //笔\n        //设置图片的背景颜色\n        g.setColor(Color.white);\n        g.fillRect(0,0,80,20);\n        //给图片写数据\n        g.setColor(Color.BLUE);\n        g.setFont(new Font(null,Font.BOLD,20));\n        g.drawString(makeNum(),0,20);\n\n        //告诉浏览器，这个请求用图片的方式打开\n        resp.setContentType(\"image/jpeg\");\n        //网站存在缓存，不让浏览器缓存\n        resp.setDateHeader(\"expires\",-1);\n        resp.setHeader(\"Cache-Control\",\"no-cache\");\n        resp.setHeader(\"Pragma\",\"no-cache\");\n\n        //把图片写给浏览器\n        ImageIO.write(image,\"jpg\", resp.getOutputStream());\n\n    }\n\n    //生成随机数\n    private String makeNum(){\n        Random random = new Random();\n        String num = random.nextInt(9999999) + \"\";\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < 7-num.length() ; i++) {\n            sb.append(\"0\");\n        }\n        num = sb.toString() + num;\n        return num;\n    }\n\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n\n#### 4、实现重定向\n\n![1567931587955](JavaWeb/1567931587955.png)\n\nB一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向\n\n常见场景：\n\n- 用户登录\n\n```java\nvoid sendRedirect(String var1) throws IOException;\n```\n\n测试：\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    /*\n        resp.setHeader(\"Location\",\"/r/img\");\n        resp.setStatus(302);\n         */\n    resp.sendRedirect(\"/r/img\");//重定向\n}\n```\n\n面试题：请你聊聊重定向和转发的区别？\n\n相同点\n\n- 页面都会实现跳转\n\n不同点\n\n- 请求转发的时候，url不会产生变化\n- 重定向时候，url地址栏会发生变化；\n\n![1567932163430](JavaWeb/1567932163430.png)\n\n#### 5、简单实现登录重定向\n\n```jsp\n<%--这里提交的路径，需要寻找到项目的路径--%>\n<%--${pageContext.request.contextPath}代表当前的项目--%>\n\n<form action=\"${pageContext.request.contextPath}/login\" method=\"get\">\n    用户名：<input type=\"text\" name=\"username\"> <br>\n    密码：<input type=\"password\" name=\"password\"> <br>\n    <input type=\"submit\">\n</form>\n\n```\n\n```JAVA\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //处理请求\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n\n        System.out.println(username+\":\"+password);\n\n        //重定向时候一定要注意，路径问题，否则404；\n        resp.sendRedirect(\"/r/success.jsp\");\n    }\n\n```\n\n```xml\n  <servlet>\n    <servlet-name>requset</servlet-name>\n    <servlet-class>com.kuang.servlet.RequestTest</servlet-class>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>requset</servlet-name>\n    <url-pattern>/login</url-pattern>\n  </servlet-mapping>\n```\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n\n<h1>Success</h1>\n\n</body>\n</html>\n\n```\n\n### 6.7、HttpServletRequest\n\nHttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；\n\n![1567933996830](JavaWeb/1567933996830.png)\n\n![1567934023106](JavaWeb/1567934023106.png)\n\n#### 获取参数，请求转发\n\n![1567934110794](JavaWeb/1567934110794.png)\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    req.setCharacterEncoding(\"utf-8\");\n    resp.setCharacterEncoding(\"utf-8\");\n\n    String username = req.getParameter(\"username\");\n    String password = req.getParameter(\"password\");\n    String[] hobbys = req.getParameterValues(\"hobbys\");\n    System.out.println(\"=============================\");\n    //后台接收中文乱码问题\n    System.out.println(username);\n    System.out.println(password);\n    System.out.println(Arrays.toString(hobbys));\n    System.out.println(\"=============================\");\n\n\n    System.out.println(req.getContextPath());\n    //通过请求转发\n    //这里的 / 代表当前的web应用\n    req.getRequestDispatcher(\"/success.jsp\").forward(req,resp);\n\n}\n```\n\n**面试题：请你聊聊重定向和转发的区别？**\n\n相同点\n\n- 页面都会实现跳转\n\n不同点\n\n- 请求转发的时候，url不会产生变化   307\n- 重定向时候，url地址栏会发生变化； 302\n\n\n\n## 7、Cookie、Session\n\n### 7.1、会话\n\n**会话**：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；\n\n**有状态会话**：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；\n\n**你能怎么证明你是西开的学生？**\n\n你              西开\n\n1. 发票                西开给你发票\n2. 学校登记        西开标记你来过了\n\n**一个网站，怎么证明你来过？**\n\n客户端              服务端\n\n1. 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie\n2. 服务器登记你来过了，下次你来的时候我来匹配你； seesion\n\n\n\n### 7.2、保存会话的两种技术\n\n**cookie**\n\n- 客户端技术   （响应，请求）\n\n**session**\n\n- 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！\n\n\n\n常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！\n\n### 7.3、Cookie\n\n![1568344447291](JavaWeb/1568344447291.png)\n\n1. 从请求中拿到cookie信息\n2. 服务器响应给客户端cookie\n\n```java\nCookie[] cookies = req.getCookies(); //获得Cookie\ncookie.getName(); //获得cookie中的key\ncookie.getValue(); //获得cookie中的vlaue\nnew Cookie(\"lastLoginTime\", System.currentTimeMillis()+\"\"); //新建一个cookie\ncookie.setMaxAge(24*60*60); //设置cookie的有效期\nresp.addCookie(cookie); //响应给客户端一个cookie\n```\n\n**cookie：一般会保存在本地的 用户目录下 appdata；**\n\n\n\n一个网站cookie是否存在上限！**聊聊细节问题**\n\n- 一个Cookie只能保存一个信息；\n- 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；\n- Cookie大小有限制4kb；\n- 300个cookie浏览器上限\n\n\n\n**删除Cookie；**\n\n- 不设置有效期，关闭浏览器，自动失效；\n- 设置有效期时间为 0 ；\n\n\n\n**编码解码：**\n\n```java\nURLEncoder.encode(\"秦疆\",\"utf-8\")\nURLDecoder.decode(cookie.getValue(),\"UTF-8\")\n```\n\n\n\n### 7.4、Session（重点）\n\n![1568344560794](JavaWeb/1568344560794.png)\n\n什么是Session：\n\n- 服务器会给每一个用户（浏览器）创建一个Seesion对象；\n- 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；\n- 用户登录之后，整个网站它都可以访问！--> 保存用户的信息；保存购物车的信息…..\n\n![1568342773861](JavaWeb/1568342773861.png)\n\nSession和cookie的区别：\n\n- Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）\n- Session把用户的数据写到用户独占Session中，服务器端保存  （保存重要的信息，减少服务器资源的浪费）\n- Session对象由服务创建；\n\n\n\n使用场景：\n\n- 保存一个登录用户的信息；\n- 购物车信息；\n- 在整个网站中经常会使用的数据，我们将它保存在Session中；\n\n\n\n使用Session：\n\n```java\npackage com.kuang.servlet;\n\nimport com.kuang.pojo.Person;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class SessionDemo01 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        \n        //解决乱码问题\n        req.setCharacterEncoding(\"UTF-8\");\n        resp.setCharacterEncoding(\"UTF-8\");\n        resp.setContentType(\"text/html;charset=utf-8\");\n        \n        //得到Session\n        HttpSession session = req.getSession();\n        //给Session中存东西\n        session.setAttribute(\"name\",new Person(\"秦疆\",1));\n        //获取Session的ID\n        String sessionId = session.getId();\n\n        //判断Session是不是新创建\n        if (session.isNew()){\n            resp.getWriter().write(\"session创建成功,ID:\"+sessionId);\n        }else {\n            resp.getWriter().write(\"session以及在服务器中存在了,ID:\"+sessionId);\n        }\n\n        //Session创建的时候做了什么事情；\n//        Cookie cookie = new Cookie(\"JSESSIONID\",sessionId);\n//        resp.addCookie(cookie);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n//得到Session\nHttpSession session = req.getSession();\n\nPerson person = (Person) session.getAttribute(\"name\");\n\nSystem.out.println(person.toString());\n\nHttpSession session = req.getSession();\nsession.removeAttribute(\"name\");\n//手动注销Session\nsession.invalidate();\n```\n\n\n\n**会话自动过期：web.xml配置**\n\n```xml\n<!--设置Session默认的失效时间-->\n<session-config>\n    <!--15分钟后Session自动失效，以分钟为单位-->\n    <session-timeout>15</session-timeout>\n</session-config>\n```\n\n\n\n![1568344679763](JavaWeb/1568344679763.png)\n\n\n\n## 8、JSP\n\n### 8.1、什么是JSP\n\nJava Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！\n\n最大的特点：\n\n- 写JSP就像在写HTML\n- 区别：\n  - HTML只给用户提供静态的数据\n  - JSP页面中可以嵌入JAVA代码，为用户提供动态数据；\n\n\n\n### 8.2、JSP原理\n\n思路：JSP到底怎么执行的！\n\n- 代码层面没有任何问题\n\n- 服务器内部工作\n\n  tomcat中有一个work目录；\n\n  IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录\n\n  ![1568345873736](JavaWeb/1568345873736.png)\n\n  我电脑的地址：\n\n  ```java\n  C:\\Users\\Administrator\\.IntelliJIdea2018.1\\system\\tomcat\\Unnamed_javaweb-session-cookie\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp\n  ```\n\n  发现页面转变成了Java程序！\n\n  ![1568345948307](JavaWeb/1568345948307.png)\n\n\n\n**浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！**\n\nJSP最终也会被转换成为一个Java类！\n\n**JSP 本质上就是一个Servlet**\n\n```java\n//初始化\n  public void _jspInit() {\n      \n  }\n//销毁\n  public void _jspDestroy() {\n  }\n//JSPService\n  public void _jspService(.HttpServletRequest request,HttpServletResponse response)\n      \n```\n\n1. 判断请求\n\n2. 内置一些对象\n\n   ```java\n   final javax.servlet.jsp.PageContext pageContext;  //页面上下文\n   javax.servlet.http.HttpSession session = null;    //session\n   final javax.servlet.ServletContext application;   //applicationContext\n   final javax.servlet.ServletConfig config;         //config\n   javax.servlet.jsp.JspWriter out = null;           //out\n   final java.lang.Object page = this;               //page：当前\n   HttpServletRequest request                        //请求\n   HttpServletResponse response                      //响应\n   ```\n\n3. 输出页面前增加的代码\n\n   ```java\n   response.setContentType(\"text/html\");       //设置响应的页面类型\n   pageContext = _jspxFactory.getPageContext(this, request, response,\n                                             null, true, 8192, true);\n   _jspx_page_context = pageContext;\n   application = pageContext.getServletContext();\n   config = pageContext.getServletConfig();\n   session = pageContext.getSession();\n   out = pageContext.getOut();\n   _jspx_out = out;\n   ```\n\n4. 以上的这些个对象我们可以在JSP页面中直接使用！\n\n![1568347078207](JavaWeb/1568347078207.png)\n\n\n\n在JSP页面中；\n\n只要是 JAVA代码就会原封不动的输出；\n\n如果是HTML代码，就会被转换为：\n\n```java\nout.write(\"<html>\\r\\n\");\n```\n\n这样的格式，输出到前端！\n\n\n\n### 8.3、JSP基础语法\n\n任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！\n\n\n\n#### **JSP表达式**\n\n```jsp\n  <%--JSP表达式\n  作用：用来将程序的输出，输出到客户端\n  <%= 变量或者表达式%>\n  --%>\n  <%= new java.util.Date()%>\n```\n\n\n\n#### **jsp脚本片段**\n\n```jsp\n\n  <%--jsp脚本片段--%>\n  <%\n    int sum = 0;\n    for (int i = 1; i <=100 ; i++) {\n      sum+=i;\n    }\n    out.println(\"<h1>Sum=\"+sum+\"</h1>\");\n  %>\n\n```\n\n\n\n**脚本片段的再实现**\n\n```jsp\n  <%\n    int x = 10;\n    out.println(x);\n  %>\n  <p>这是一个JSP文档</p>\n  <%\n    int y = 2;\n    out.println(y);\n  %>\n\n  <hr>\n\n\n  <%--在代码嵌入HTML元素--%>\n  <%\n    for (int i = 0; i < 5; i++) {\n  %>\n    <h1>Hello,World  <%=i%> </h1>\n  <%\n    }\n  %>\n```\n\n\n\n#### JSP声明\n\n```jsp\n  <%!\n    static {\n      System.out.println(\"Loading Servlet!\");\n    }\n\n    private int globalVar = 0;\n\n    public void kuang(){\n      System.out.println(\"进入了方法Kuang！\");\n    }\n  %>\n```\n\n\n\nJSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！\n\n在JSP，嵌入Java代码即可！\n\n```jsp\n<%%>\n<%=%>\n<%!%>\n\n<%--注释--%>\n```\n\nJSP的注释，不会在客户端显示，HTML就会！\n\n\n\n### 8.4、JSP指令\n\n```jsp\n<%@page args.... %>\n<%@include file=\"\"%>\n\n<%--@include会将两个页面合二为一--%>\n\n<%@include file=\"common/header.jsp\"%>\n<h1>网页主体</h1>\n\n<%@include file=\"common/footer.jsp\"%>\n\n<hr>\n\n\n<%--jSP标签\n    jsp:include：拼接页面，本质还是三个\n    --%>\n<jsp:include page=\"/common/header.jsp\"/>\n<h1>网页主体</h1>\n<jsp:include page=\"/common/footer.jsp\"/>\n\n```\n\n\n\n### 8.5、9大内置对象\n\n- PageContext    存东西\n- Request     存东西\n- Response\n- Session      存东西\n- Application   【SerlvetContext】   存东西\n- config    【SerlvetConfig】\n- out\n- page ，不用了解\n- exception\n\n```java\npageContext.setAttribute(\"name1\",\"秦疆1号\"); //保存的数据只在一个页面中有效\nrequest.setAttribute(\"name2\",\"秦疆2号\"); //保存的数据只在一次请求中有效，请求转发会携带这个数据\nsession.setAttribute(\"name3\",\"秦疆3号\"); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器\napplication.setAttribute(\"name4\",\"秦疆4号\");  //保存的数据只在服务器中有效，从打开服务器到关闭服务器\n```\n\nrequest：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！\n\nsession：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；\n\napplication：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；\n\n### 8.6、JSP标签、JSTL标签、EL表达式\n\n```xml\n<!-- JSTL表达式的依赖 -->\n<dependency>\n    <groupId>javax.servlet.jsp.jstl</groupId>\n    <artifactId>jstl-api</artifactId>\n    <version>1.2</version>\n</dependency>\n<!-- standard标签库 -->\n<dependency>\n    <groupId>taglibs</groupId>\n    <artifactId>standard</artifactId>\n    <version>1.1.2</version>\n</dependency>\n\n```\n\nEL表达式：  ${ }\n\n- **获取数据**\n- **执行运算**\n- **获取web开发的常用对象**\n\n\n\n**JSP标签**\n\n```jsp\n<%--jsp:include--%>\n\n<%--\nhttp://localhost:8080/jsptag.jsp?name=kuangshen&age=12\n--%>\n\n<jsp:forward page=\"/jsptag2.jsp\">\n    <jsp:param name=\"name\" value=\"kuangshen\"></jsp:param>\n    <jsp:param name=\"age\" value=\"12\"></jsp:param>\n</jsp:forward>\n```\n\n\n\n**JSTL表达式**\n\nJSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！\n\n**格式化标签**\n\n**SQL标签**\n\n**XML 标签**\n\n**核心标签** （掌握部分）\n\n![1568362473764](JavaWeb/1568362473764.png)\n\n**JSTL标签库使用步骤**\n\n- 引入对应的 taglib\n- 使用其中的方法\n- **在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误**\n\nc：if\n\n```jsp\n<head>\n    <title>Title</title>\n</head>\n<body>\n\n\n<h4>if测试</h4>\n\n<hr>\n\n<form action=\"coreif.jsp\" method=\"get\">\n    <%--\n    EL表达式获取表单中的数据\n    ${param.参数名}\n    --%>\n    <input type=\"text\" name=\"username\" value=\"${param.username}\">\n    <input type=\"submit\" value=\"登录\">\n</form>\n\n<%--判断如果提交的用户名是管理员，则登录成功--%>\n<c:if test=\"${param.username=='admin'}\" var=\"isAdmin\">\n    <c:out value=\"管理员欢迎您！\"/>\n</c:if>\n\n<%--自闭合标签--%>\n<c:out value=\"${isAdmin}\"/>\n\n</body>\n```\n\nc:choose   c:when\n\n```jsp\n<body>\n\n<%--定义一个变量score，值为85--%>\n<c:set var=\"score\" value=\"55\"/>\n\n<c:choose>\n    <c:when test=\"${score>=90}\">\n        你的成绩为优秀\n    </c:when>\n    <c:when test=\"${score>=80}\">\n        你的成绩为一般\n    </c:when>\n    <c:when test=\"${score>=70}\">\n        你的成绩为良好\n    </c:when>\n    <c:when test=\"${score<=60}\">\n        你的成绩为不及格\n    </c:when>\n</c:choose>\n\n</body>\n```\n\nc:forEach\n\n```jsp\n<%\n\n    ArrayList<String> people = new ArrayList<>();\n    people.add(0,\"张三\");\n    people.add(1,\"李四\");\n    people.add(2,\"王五\");\n    people.add(3,\"赵六\");\n    people.add(4,\"田六\");\n    request.setAttribute(\"list\",people);\n%>\n\n\n<%--\nvar , 每一次遍历出来的变量\nitems, 要遍历的对象\nbegin,   哪里开始\nend,     到哪里\nstep,   步长\n--%>\n<c:forEach var=\"people\" items=\"${list}\">\n    <c:out value=\"${people}\"/> <br>\n</c:forEach>\n\n<hr>\n\n<c:forEach var=\"people\" items=\"${list}\" begin=\"1\" end=\"3\" step=\"1\" >\n    <c:out value=\"${people}\"/> <br>\n</c:forEach>\n\n```\n\n## 9、JavaBean\n\n实体类\n\nJavaBean有特定的写法：\n\n- 必须要有一个无参构造\n- 属性必须私有化\n- 必须有对应的get/set方法；\n\n一般用来和数据库的字段做映射  ORM；\n\nORM ：对象关系映射\n\n- 表--->类\n- 字段-->属性\n- 行记录---->对象\n\n**people表**\n\n| id   | name    | age  | address |\n| ---- | ------- | ---- | ------- |\n| 1    | 秦疆1号 | 3    | 西安    |\n| 2    | 秦疆2号 | 18   | 西安    |\n| 3    | 秦疆3号 | 100  | 西安    |\n\n```java\nclass People{\n    private int id;\n    private String name;\n    private int id;\n    private String address;\n}\n\nclass A{\n    new People(1,\"秦疆1号\",3，\"西安\");\n    new People(2,\"秦疆2号\",3，\"西安\");\n    new People(3,\"秦疆3号\",3，\"西安\");\n}\n```\n\n\n\n- 过滤器\n- 文件上传\n- 邮件发送\n- JDBC 复习 ： 如何使用JDBC ,  JDBC crud， jdbc 事务\n\n\n\n## 10、MVC三层架构\n\n什么是MVC：  Model     view     Controller  模型、视图、控制器\n\n### 10.1、早些年\n\n![1568423664332](JavaWeb/1568423664332.png)\n\n用户直接访问控制层，控制层就可以直接操作数据库；\n\n```java\nservlet--CRUD-->数据库\n弊端：程序十分臃肿，不利于维护  \nservlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码\n\n架构：没有什么是加一层解决不了的！\n程序猿调用\n|\nJDBC\n|\nMysql Oracle SqlServer ....\n```\n\n### 10.2、MVC三层架构\n\n![1568424227281](JavaWeb/1568424227281.png)\n\n\n\nModel\n\n- 业务处理 ：业务逻辑（Service）\n- 数据持久层：CRUD   （Dao）\n\nView\n\n- 展示数据\n- 提供链接发起Servlet请求 （a，form，img…）\n\nController  （Servlet）\n\n- 接收用户的请求 ：（req：请求参数、Session信息….）\n\n- 交给业务层处理对应的代码 \n\n- 控制视图的跳转  \n\n  ```java\n  登录--->接收用户的登录请求--->处理用户的请求（获取用户登录的参数，username，password）---->交给业务层处理登录业务（判断用户名密码是否正确：事务）--->Dao层查询用户名和密码是否正确-->数据库\n  ```\n\n\n\n## 11、Filter （重点）\n\nFilter：过滤器 ，用来过滤网站的数据；\n\n- 处理中文乱码\n- 登录验证….\n\n![1568424858708](JavaWeb/1568424858708.png)\n\nFilter开发步骤：\n\n1. 导包\n\n2. 编写过滤器\n\n   1. 导包不要错\n\n      ![1568425162525](JavaWeb/1568425162525.png)\n\n      实现Filter接口，重写对应的方法即可\n\n      ```java\n      public class CharacterEncodingFilter implements Filter {\n      \n          //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！\n          public void init(FilterConfig filterConfig) throws ServletException {\n              System.out.println(\"CharacterEncodingFilter初始化\");\n          }\n      \n          //Chain : 链\n          /*\n          1. 过滤中的所有代码，在过滤特定请求的时候都会执行\n          2. 必须要让过滤器继续同行\n              chain.doFilter(request,response);\n           */\n          public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n              request.setCharacterEncoding(\"utf-8\");\n              response.setCharacterEncoding(\"utf-8\");\n              response.setContentType(\"text/html;charset=UTF-8\");\n      \n              System.out.println(\"CharacterEncodingFilter执行前....\");\n              chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！\n              System.out.println(\"CharacterEncodingFilter执行后....\");\n          }\n      \n          //销毁：web服务器关闭的时候，过滤会销毁\n          public void destroy() {\n              System.out.println(\"CharacterEncodingFilter销毁\");\n          }\n      }\n      \n      ```\n\n3. 在web.xml中配置 Filter\n\n   ```xml\n   <filter>\n       <filter-name>CharacterEncodingFilter</filter-name>\n       <filter-class>com.kuang.filter.CharacterEncodingFilter</filter-class>\n   </filter>\n   <filter-mapping>\n       <filter-name>CharacterEncodingFilter</filter-name>\n       <!--只要是 /servlet的任何请求，会经过这个过滤器-->\n       <url-pattern>/servlet/*</url-pattern>\n       <!--<url-pattern>/*</url-pattern>-->\n   </filter-mapping>\n   ```\n\n   \n\n## 12、监听器\n\n实现一个监听器的接口；（有N种）\n\n1. 编写一个监听器\n\n   实现监听器的接口…\n\n   ```java\n   //统计网站在线人数 ： 统计session\n   public class OnlineCountListener implements HttpSessionListener {\n   \n       //创建session监听： 看你的一举一动\n       //一旦创建Session就会触发一次这个事件！\n       public void sessionCreated(HttpSessionEvent se) {\n           ServletContext ctx = se.getSession().getServletContext();\n   \n           System.out.println(se.getSession().getId());\n   \n           Integer onlineCount = (Integer) ctx.getAttribute(\"OnlineCount\");\n   \n           if (onlineCount==null){\n               onlineCount = new Integer(1);\n           }else {\n               int count = onlineCount.intValue();\n               onlineCount = new Integer(count+1);\n           }\n   \n           ctx.setAttribute(\"OnlineCount\",onlineCount);\n   \n       }\n   \n       //销毁session监听\n       //一旦销毁Session就会触发一次这个事件！\n       public void sessionDestroyed(HttpSessionEvent se) {\n           ServletContext ctx = se.getSession().getServletContext();\n   \n           Integer onlineCount = (Integer) ctx.getAttribute(\"OnlineCount\");\n   \n           if (onlineCount==null){\n               onlineCount = new Integer(0);\n           }else {\n               int count = onlineCount.intValue();\n               onlineCount = new Integer(count-1);\n           }\n   \n           ctx.setAttribute(\"OnlineCount\",onlineCount);\n   \n       }\n   \n   \n       /*\n       Session销毁：\n       1. 手动销毁  getSession().invalidate();\n       2. 自动销毁\n        */\n   }\n   \n   ```\n\n2. web.xml中注册监听器\n\n   ```xml\n   <!--注册监听器-->\n   <listener>\n       <listener-class>com.kuang.listener.OnlineCountListener</listener-class>\n   </listener>\n   ```\n\n3. 看情况是否使用！\n\n\n\n## 13、过滤器、监听器常见应用\n\n**监听器：GUI编程中经常使用；**\n\n```java\npublic class TestPanel {\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"中秋节快乐\");  //新建一个窗体\n        Panel panel = new Panel(null); //面板\n        frame.setLayout(null); //设置窗体的布局\n\n        frame.setBounds(300,300,500,500);\n        frame.setBackground(new Color(0,0,255)); //设置背景颜色\n\n        panel.setBounds(50,50,300,300);\n        panel.setBackground(new Color(0,255,0)); //设置背景颜色\n\n        frame.add(panel);\n\n        frame.setVisible(true);\n\n        //监听事件，监听关闭事件\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                super.windowClosing(e);\n            }\n        });\n\n\n    }\n}\n```\n\n\n\n用户登录之后才能进入主页！用户注销后就不能进入主页了！\n\n1. 用户登录之后，向Sesison中放入用户的数据\n\n2. 进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！\n\n   ```java\n   HttpServletRequest request = (HttpServletRequest) req;\n   HttpServletResponse response = (HttpServletResponse) resp;\n   \n   if (request.getSession().getAttribute(Constant.USER_SESSION)==null){\n       response.sendRedirect(\"/error.jsp\");\n   }\n   \n   chain.doFilter(request,response);\n   ```\n\n\n\n\n## 14、JDBC\n\n什么是JDBC ： Java连接数据库！\n\n![1568439601825](JavaWeb/1568439601825.png)\n\n需要jar包的支持：\n\n- java.sql\n- javax.sql\n- mysql-conneter-java…  连接驱动（必须要导入）\n\n\n\n**实验环境搭建**\n\n```sql\n\nCREATE TABLE users(\n    id INT PRIMARY KEY,\n    `name` VARCHAR(40),\n    `password` VARCHAR(40),\n    email VARCHAR(60),\n    birthday DATE\n);\n\nINSERT INTO users(id,`name`,`password`,email,birthday)\nVALUES(1,'张三','123456','zs@qq.com','2000-01-01');\nINSERT INTO users(id,`name`,`password`,email,birthday)\nVALUES(2,'李四','123456','ls@qq.com','2000-01-01');\nINSERT INTO users(id,`name`,`password`,email,birthday)\nVALUES(3,'王五','123456','ww@qq.com','2000-01-01');\n\n\nSELECT\t* FROM users;\n\n```\n\n\n\n导入数据库依赖\n\n```xml\n<!--mysql的驱动-->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.47</version>\n</dependency>\n```\n\nIDEA中连接数据库：\n\n![1568440926845](JavaWeb/1568440926845.png)\n\n\n\n**JDBC 固定步骤：**\n\n1. 加载驱动\n2. 连接数据库,代表数据库\n3. 向数据库发送SQL的对象Statement : CRUD\n4. 编写SQL （根据业务，不同的SQL）\n5. 执行SQL\n6. 关闭连接\n\n```java\npublic class TestJdbc {\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //配置信息\n        //useUnicode=true&characterEncoding=utf-8 解决中文乱码\n        String url=\"jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8\";\n        String username = \"root\";\n        String password = \"123456\";\n\n        //1.加载驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        //2.连接数据库,代表数据库\n        Connection connection = DriverManager.getConnection(url, username, password);\n\n        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD\n        Statement statement = connection.createStatement();\n\n        //4.编写SQL\n        String sql = \"select * from users\";\n\n        //5.执行查询SQL，返回一个 ResultSet  ： 结果集\n        ResultSet rs = statement.executeQuery(sql);\n\n        while (rs.next()){\n            System.out.println(\"id=\"+rs.getObject(\"id\"));\n            System.out.println(\"name=\"+rs.getObject(\"name\"));\n            System.out.println(\"password=\"+rs.getObject(\"password\"));\n            System.out.println(\"email=\"+rs.getObject(\"email\"));\n            System.out.println(\"birthday=\"+rs.getObject(\"birthday\"));\n        }\n\n        //6.关闭连接，释放资源（一定要做） 先开后关\n        rs.close();\n        statement.close();\n        connection.close();\n    }\n}\n\n```\n\n\n\n**预编译SQL**\n\n```java\npublic class TestJDBC2 {\n    public static void main(String[] args) throws Exception {\n        //配置信息\n        //useUnicode=true&characterEncoding=utf-8 解决中文乱码\n        String url=\"jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8\";\n        String username = \"root\";\n        String password = \"123456\";\n\n        //1.加载驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        //2.连接数据库,代表数据库\n        Connection connection = DriverManager.getConnection(url, username, password);\n\n        //3.编写SQL\n        String sql = \"insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);\";\n\n        //4.预编译\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；\n        preparedStatement.setString(2,\"狂神说Java\");//给第二个占位符？ 的值赋值为狂神说Java；\n        preparedStatement.setString(3,\"123456\");//给第三个占位符？ 的值赋值为123456；\n        preparedStatement.setString(4,\"24736743@qq.com\");//给第四个占位符？ 的值赋值为1；\n        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；\n\n        //5.执行SQL\n        int i = preparedStatement.executeUpdate();\n\n        if (i>0){\n            System.out.println(\"插入成功@\");\n        }\n\n        //6.关闭连接，释放资源（一定要做） 先开后关\n        preparedStatement.close();\n        connection.close();\n    }\n}\n\n```\n\n\n\n**事务**\n\n要么都成功，要么都失败！\n\nACID原则：保证数据的安全。\n\n```java\n开启事务\n事务提交  commit()\n事务回滚  rollback()\n关闭事务\n\n转账：\nA:1000\nB:1000\n    \nA(900)   --100-->   B(1100) \n```\n\n\n\n**Junit单元测试**\n\n依赖\n\n```xml\n<!--单元测试-->\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n```\n\n简单使用\n\n@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！\n\n```java\n@Test\npublic void test(){\n    System.out.println(\"Hello\");\n}\n```\n\n![1568442261610](JavaWeb/1568442261610.png)\n\n失败的时候是红色：\n\n![1568442289597](JavaWeb/1568442289597.png)\n\n\n\n**搭建一个环境**\n\n```sql\nCREATE TABLE account(\n   id INT PRIMARY KEY AUTO_INCREMENT,\n   `name` VARCHAR(40),\n   money FLOAT\n);\n\nINSERT INTO account(`name`,money) VALUES('A',1000);\nINSERT INTO account(`name`,money) VALUES('B',1000);\nINSERT INTO account(`name`,money) VALUES('C',1000);\n```\n\n```java\n    @Test\n    public void test() {\n        //配置信息\n        //useUnicode=true&characterEncoding=utf-8 解决中文乱码\n        String url=\"jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8\";\n        String username = \"root\";\n        String password = \"123456\";\n\n        Connection connection = null;\n\n        //1.加载驱动\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //2.连接数据库,代表数据库\n             connection = DriverManager.getConnection(url, username, password);\n\n            //3.通知数据库开启事务,false 开启\n            connection.setAutoCommit(false);\n\n            String sql = \"update account set money = money-100 where name = 'A'\";\n            connection.prepareStatement(sql).executeUpdate();\n\n            //制造错误\n            //int i = 1/0;\n\n            String sql2 = \"update account set money = money+100 where name = 'B'\";\n            connection.prepareStatement(sql2).executeUpdate();\n\n            connection.commit();//以上两条SQL都执行成功了，就提交事务！\n            System.out.println(\"success\");\n        } catch (Exception e) {\n            try {\n                //如果出现异常，就通知数据库回滚事务\n                connection.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            e.printStackTrace();\n        }finally {\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n","tags":["基础","JavaWeb"],"categories":["Java"]},{"title":"Angular中何时取消订阅（译）","url":"/2020/06/16/Angular中何时取消订阅/","content":"\n\n在js中，当你订阅observable或event时，你需要及时取消订阅来避免内存泄漏。\n\n下面是几种需要在生命周期`ngOnDestroy`中取消订阅的情况。\n\n## Forms\n\n```ts\nexport class TestComponent {\n\n  ngOnInit() {\n    this.form = new FormGroup({...});\n    this.valueChanges  = this.form.valueChanges.subscribe(console.log);\n    this.statusChanges = this.form.statusChanges.subscribe(console.log);\n  }\n\n  ngOnDestroy() {\n    this.valueChanges.unsubscribe();\n    this.statusChanges.unsubscribe();\n  }\n\n}\n\n```\n这同样适用于任一的form control 。\n\n## The Router\n\n```ts\nexport class TestComponent {\n  constructor(private route: ActivatedRoute, private router: Router) { }\n\n  ngOnInit() {\n    this.route.params.subscribe(console.log);\n    this.route.queryParams.subscribe(console.log);\n    this.route.fragment.subscribe(console.log);\n    this.route.data.subscribe(console.log);\n    this.route.url.subscribe(console.log);\n    \n    this.router.events.subscribe(console.log);\n  }\n\n  ngOnDestroy() {\n    // You should unsubscribe from each observable here\n  }\n\n}\n\n```\n根据官方文档，Angular应该为你取消了订阅，但显而易见的，这是一个[bug](https://github.com/angular/angular/issues/16261)\n\n## Renderer Service\n\n```ts\nexport class TestComponent {\nconstructor(private renderer: Renderer2, \n            private element : ElementRef) { }\n\n  ngOnInit() {\n    this.click = this.renderer.listen(this.element.nativeElement, \"click\", handler);\n  }\n\n  ngOnDestroy() {\n    this.click.unsubscribe();\n  }\n\n}\n\n```\n\n## Infinite Observables\n\n当你使用无限发出流的Observables，你应该取消订阅（除非有特殊情况）。eg:`interval()`或`fromEvent()`\n\n```ts\nexport class TestComponent {\n\n  constructor(private element : ElementRef) { }\n\n  interval: Subscription;\n  click: Subscription;\n\n  ngOnInit() {\n    this.interval = Observable.interval(1000).subscribe(console.log);\n    this.click = Observable.fromEvent(this.element.nativeElement, 'click').subscribe(console.log);\n  }\n\n  ngOnDestroy() {\n    this.interval.unsubscribe();\n    this.click.unsubscribe();\n  }\n\n}\n\n```\n\n## Redux Store\n\n```ts\nexport class TestComponent {\n\n  constructor(private store: Store) { }\n\n  todos: Subscription;\n\n  ngOnInit() {\n     this.todos = this.store.select('todos').subscribe(console.log);  \n  }\n\n  ngOnDestroy() {\n    this.todos.unsubscribe();\n  }\n\n}\n\n```\n\n# 不能取消订阅\n\n## Async pipe\n\n```ts\n@Component({\n  selector: 'test',\n  template: `<todos [todos]=\"todos$ | async\"></todos>`\n})\nexport class TestComponent {\n\n  constructor(private store: Store) { }\n\n  ngOnInit() {\n     this.todos$ = this.store.select('todos');\n  }\n\n}\n\n```\n当组件销毁的时候`async`管道会自动取消订阅，以避免内存泄漏。\n\n## @HostListener\n\n```ts\nexport class TestDirective {\n\n  @HostListener('click')\n  onClick() {\n    ....\n  }\n\n}\n\n\n```\n\n## Finite Observable\n\n当你使用发出有限流的Observable时，通常情况下不需要取消订阅，eg:`HTTP`服务或`timer`\n\n```ts\nexport class TestComponent {\n\n  constructor(private http: Http) { }\n\n  ngOnInit() {\n    Observable.timer(1000).subscribe(console.log);\n    this.http.get('http://api.com').subscribe(console.log);\n  }\n\n\n}\n\n```\n\n## 最后小结\n你应该尽可能少的调用`unsubscribe `方法\n\n```ts\nexport class TestComponent {\n\n  constructor(private store: Store) { }\n\n  private componetDestroyed: Subject = new Subject();\n  todos: Subscription;\n  posts: Subscription;\n\n  ngOnInit() {\n     this.todos = this.store.select('todos').takeUntil(this.componetDestroyed).subscribe(console.log); \n\n     this.posts = this.store.select('posts').takeUntil(this.componetDestroyed).subscribe(console.log); \n  }\n\n  ngOnDestroy() {\n    this.componetDestroyed.next();\n    this.componetDestroyed.unsubscribe();\n  }\n\n}\n```\n\n> 原文链接: https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3\n\n","tags":["Angular","rxjs"],"categories":["js"]}]